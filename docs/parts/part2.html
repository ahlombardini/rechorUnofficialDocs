<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Étape 2 - ReCHor Documentation</title>
    <style>
        :root {
            --primary-color: #1976D2;
            --secondary-color: #2196F3;
            --accent-color: #4CAF50;
            --background-color: #f5f5f5;
            --text-color: #333;
        }

        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            color: var(--text-color);
            background: var(--background-color);
        }

        .header {
            background: var(--primary-color);
            color: white;
            padding: 1rem 2rem;
            margin-bottom: 2rem;
            display: flex;
            align-items: center;
        }

        .header a {
            color: white;
            text-decoration: none;
            display: inline-block;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .header a:hover {
            background-color: rgba(255, 255, 255, 0.1);
            text-decoration: none;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        h2 {
            color: var(--primary-color);
            margin-top: 0;
        }

        .card-title {
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            margin: 0 0 1rem 0;
            color: var(--primary-color);
            font-size: 1.2rem;
        }

        .class-card, .concept-card {
            background: white;
            padding: 1.5rem;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: all 0.2s ease-in-out;
            margin-bottom: 1rem;
        }

        .class-card:hover, .concept-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .card-title {
            margin: 0 0 1rem 0;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #eee;
        }

        .card-title a {
            color: var(--primary-color);
            text-decoration: none;
            font-size: 1.2rem;
        }

        .card-title a:hover {
            color: var(--secondary-color);
        }

        .class-content, .concept-content {
            font-size: 0.95em;
            color: var(--text-color);
            overflow: auto;
            max-height: 500px;
            padding-right: 1rem;
        }

        .class-content p, .concept-content p {
            margin: 0.5rem 0;
        }

        .class-content pre, .concept-content pre {
            background: var(--background-color);
            padding: 1rem;
            border-radius: 4px;
            overflow-x: auto;
            margin: 1rem 0;
        }

        .class-grid, .concept-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 1.5rem;
            margin: 1rem 0;
        }

        .class-card .card-title {
            margin: 0;
        }

        .class-card, .concept-card {
            min-height: 100px;
            height: fit-content;
            display: flex;
            flex-direction: column;
            background: white;
            padding: 1.5rem;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }

        .concept-card {
            margin-bottom: 1rem;
        }

        .concept-card:hover, .class-card:hover {
            transform: translateY(-2px);
        }

        .concept-content {
            font-size: 0.95em;
            color: var(--text-color);
            overflow: auto;
            max-height: 300px;
            margin-top: 0.5rem;
        }

        .concept-content p {
            margin: 0.5rem 0;
        }

        .concept-content ol, .concept-content ul {
            margin: 0.5rem 0;
            padding-left: 1.5rem;
        }

        .concept-content a {
            color: var(--primary-color);
            text-decoration: none;
        }

        .concept-content a:hover {
            text-decoration: underline;
        }

        .concepts-section {
            margin: 2rem 0;
        }

        .concepts-section h3 {
            color: var(--primary-color);
            margin-bottom: 1rem;
        }

        .class-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            margin: 1rem 0;
        }

        .class-card a {
            text-decoration: none;
        }

        .introduction {
            background: white;
            padding: 2rem;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
        }

        .subtitle {
            font-style: italic;
            color: var(--secondary-color);
            margin: 1rem 0;
        }

        img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 1rem auto;
        }

        figure {
            margin: 2rem 0;
            text-align: center;
        }

        figcaption {
            font-style: italic;
            color: var(--text-color);
            margin-top: 0.5rem;
        }

        .concept-preview {
            color: var(--text-color);
            font-size: 0.9em;
            margin-top: 0.5rem;
            opacity: 0.8;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        .concept-card {
            min-height: 100px;
            height: fit-content;
            background: white;
            padding: 1.5rem;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: all 0.2s ease-in-out;
        }

        .concept-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .concept-card a {
            text-decoration: none;
            color: inherit;
            display: block;
            height: 100%;
        }
    </style>
</head>
<body>
    <header class="header">
        <a href="../index.html">← Retour à l'index</a>
    </header>
    <div class="container">
        <h2>Étape 2 - iCalendar et valeurs empaquetées</h2>
<p class="subtitle">ReCHor – étape 2</p>

            <div class="introduction">
                <div class="outline-text-2" id="text-1">
<p>
Le but de cette seconde étape est double : premièrement, écrire le code permettant d'exporter un voyage au format iCalendar, et deuxièmement écrire celui permettant de manipuler deux types de valeurs « empaquetées » dans des entiers Java — les intervalles d'entiers, et les critères d'optimisation des voyages.
</p>
<p>
Avant de la commencer, lisez le guide <a href="../g/backups.html"><i>Sauvegarder son travail</i></a>, qui vous donnera des conseils importants concernant la sauvegarde de votre projet au cours du semestre.
</p>
</div>
            </div>
        
                <div class="concepts-section">
                    <h3>Concepts clés</h3>
                    <div class="concept-grid">
            
        <div class="concept-card">
            <h3 class="card-title">
                <a href="../concepts/part2_format_icalendar.html">Format iCalendar</a>
            </h3>
            <div class="concept-preview">Comme nous l'avons vu dans l'introduction au projet, une des fonctionnalités offertes par ReCHor ...</div>
        </div>
    
        <div class="concept-card">
            <h3 class="card-title">
                <a href="../concepts/part2_valeurs_empaquetees.html">Valeurs empaquetées</a>
            </h3>
            <div class="concept-preview">Comme expliqué dans le cours sur les types entiers, l'empaquetage consiste à stocker plusieurs va...</div>
        </div>
    
                    </div>
                </div>
        
                <div class="class-section">
                    <h3>Classes et Interfaces</h3>
                    <div class="class-grid">
        
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/IcalBuilder.html">IcalBuilder</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-3-1">
<p>
La classe <code>IcalBuilder</code> du paquetage principal, publique et finale, représente un bâtisseur d'événement au format iCalendar. Elle possède deux types énumérés publics imbriqués, qui sont :
</p>
<dl class="org-dl">
<dt><code>Component</code></dt><dd>qui représente un composant ou un objet, et dont les valeurs sont (dans l'ordre) : <code>VCALENDAR</code> et <code>VEVENT</code>,</dd>
<dt><code>Name</code></dt><dd>qui représente un nom d'une ligne, et dont les valeurs sont (dans l'ordre) : <code>BEGIN</code>, <code>END</code>, <code>PRODID</code>, <code>VERSION</code>, <code>UID</code>, <code>DTSTAMP</code>, <code>DTSTART</code>, <code>DTEND</code>, <code>SUMMARY</code> et <code>DESCRIPTION</code>.</dd>
</dl>
<p>
De plus, <code>IcalBuilder</code> possède les méthodes publiques suivantes :
</p>
<dl class="org-dl">
<dt><code>IcalBuilder add(Name name, String value)</code></dt><dd>qui ajoute à l'événement en cours de construction une ligne dont le nom et la valeur sont ceux donnés, en prenant garde à « plier » la ligne au besoin afin de respecter la contrainte qu'aucune ligne d'une donnée iCalendar ne devrait dépasser 75 caractères,</dd>
<dt><code>IcalBuilder add(Name name, LocalDateTime dateTime)</code></dt><dd>qui ajoute à l'événement en cours de construction une ligne dont le nom est celui donné et la valeur est la représentation textuelle de la date/heure donnée, au format spécifié à la §<a href="#sec/ical/dt">2.1.6</a>,</dd>
<dt><code>IcalBuilder begin(Component component)</code></dt><dd>qui commence un composant en ajoutant une ligne dont le nom est <code>BEGIN</code> et la valeur est le nom du composant donné,</dd>
<dt><code>IcalBuilder end()</code></dt><dd>qui termine le dernier composant qui a été commencé précédemment par <code>begin</code> mais pas encore terminé par un appel à <code>end</code> précédent, ou lève une <code>IllegalArgumentException</code> s'il n'y en a aucun (voir les conseils de programmation),</dd>
<dt><code>String build()</code></dt><dd>qui retourne la chaîne de caractères au format iCalendar représentant l'événement en cours de construction, ou lève une <code>IllegalArgumentException</code> si un composant qui a été commencé par un appel à <code>begin</code> n'a, à ce stade, pas été terminé par un appel à <code>end</code>.</dd>
</dl>
</div>
            </div>
        </div>
    
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/JourneyIcalConverter.html">JourneyIcalConverter</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-3-2">
<p>
La classe <code>JourneyIcalConverter</code> du sous-paquetage <code>journey</code>, publique et non instanciable, offre une méthode permettant de convertir un voyage en un événement :
</p>
<dl class="org-dl">
<dt><code>String toIcalendar(Journey journey)</code></dt><dd>qui retourne une chaîne de caractères au format iCalendar représentant l'événement qui correspond au voyage donné.</dd>
</dl>
<p>
L'événement retourné par <code>toIcalendar</code> doit avoir exactement la même structure que celui donné en exemple à la §<a href="#sec/ical/example">2.1.8</a>, et doit donc consister en :
</p>
<ul class="org-ul">
<li>un objet <code>VCALENDAR</code> à la racine avec :
<ul class="org-ul">
<li>un attribut <code>VERSION</code> valant <code>2.0</code>,</li>
<li>un attribut <code>PRODID</code> valant <code>ReCHor</code>,</li>
<li>un composant <code>VEVENT</code> imbriqué avec :
<ul class="org-ul">
<li>un attribut <code>UID</code> dont la valeur est un UUID aléatoire (voir les conseils de programmation),</li>
<li>un attribut <code>DTSTAMP</code> dont la valeur est la date/heure au moment de l'appel de la méthode (voir les conseils de programmation),</li>
<li>un attribut <code>DTSTART</code> dont la valeur est la date/heure du début du voyage,</li>
<li>un attribut <code>DTEND</code> dont la valeur est la date/heure de la fin du voyage,</li>
<li>un attribut <code>SUMMARY</code> dont la valeur est le nom de la gare de départ et celle d'arrivée, séparés d'une flèche (<code>→</code>) entourée d'espaces,</li>
<li>un attribut <code>DESCRIPTION</code> dont la valeur est la représentation textuelle des différentes étapes du voyage, chacune sur une ligne, obtenue au moyen des méthodes de <code>FormatterFr</code>.</li>
</ul></li>
</ul></li>
</ul>
<p>
Pour vérifier que les événements produits par votre méthode sont syntaxiquement corrects, vous pouvez utiliser <a href="https://icalendar.org/validator.html">le validateur iCalendar en ligne</a>.
</p>
</div>
            </div>
        </div>
    
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/Bits32_24_8.html">Bits32_24_8</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-3-3">
<p>
La classe <code>Bits32_24_8</code> du paquetage principal, publique et non instanciable, contient des méthodes statiques permettant de manipuler une paire de valeurs — de 24 et 8 bits respectivement — empaquetées dans un entier de 32 bits de type <code>int</code>.
</p>
<p>
Cette classe existe car il se trouve que plusieurs paires de valeurs utiles dans ce projet, dont les intervalles d'entiers, peuvent être empaquetées de la sorte, et il semble donc raisonnable de partager le code les manipulant.
</p>
<p>
Les méthodes publiques (et statiques) offertes par <code>Bits32_24_8</code> sont :
</p>
<dl class="org-dl">
<dt><code>int pack(int bits24, int bits8)</code></dt><dd>qui retourne le vecteur de 32 bits dont les 24 bits de poids fort sont <code>bits24</code> et les 8 bits de poids faible sont <code>bits8</code>, ou lève une <code>IllegalArgumentException</code> si l'une des deux valeurs nécessite plus de bits qu'elle ne devrait (24 et 8, respectivement, voir les conseils de programmation),</dd>
<dt><code>int unpack24(int bits32)</code></dt><dd>qui retourne les 24 bits de poids fort du vecteur de 32 bits donné,</dd>
<dt><code>int unpack8(int bits32)</code></dt><dd>qui retourne les 8 bits de poids faible du vecteur de 32 bits donné.</dd>
</dl>
</div>
            </div>
        </div>
    
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/PackedRange.html">PackedRange</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-3-4">
<p>
La classe <code>PackedRange</code> du paquetage principal, publique et non instanciable, offre des méthodes permettant de manipuler des intervalles d'entiers empaquetés dans un entier de type <code>int</code>. Dans cette représentation, les 24 bits de poids fort contiennent la borne inférieure de l'intervalle, tandis que les 8 bits de poids faible contiennent sa longueur.
</p>
<p>
<code>PackedRange</code> offre les méthodes publiques (et statiques) suivantes :
</p>
<dl class="org-dl">
<dt><code>int pack(int startInclusive, int endExclusive)</code></dt><dd>qui retourne la valeur de type <code>int</code> représentant l'intervalle d'entiers allant de <code>startInclusive</code> (inclus) à <code>endExclusive</code> (exclu), ou lève une <code>IllegalArgumentException</code> si cet intervalle ne peut pas être empaqueté (soit parce que sa borne inférieure ne peut être représentée avec 24 bits, ou parce que sa longueur ne peut être représentée avec 8 bits),</dd>
<dt><code>int length(int interval)</code></dt><dd>qui retourne la longueur de l'intervalle d'entiers empaqueté donné,</dd>
<dt><code>int startInclusive(int interval)</code></dt><dd>qui retourne le début de l'intervalle d'entiers empaqueté donné, c.-à-d. le plus petit entier qui en fait partie,</dd>
<dt><code>int endExclusive(int interval)</code></dt><dd>qui retourne le plus petit entier strictement supérieur à tous les entiers de l'intervalle.</dd>
</dl>
</div>
            </div>
        </div>
    
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/PackedCriteria.html">PackedCriteria</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-3-5">
<p>
La classe <code>PackedCriteria</code> du sous-paquetage <code>journey</code>, publique et non instanciable, contient des méthodes statiques permettant de manipuler des critères d'optimisation augmentés, empaquetés dans des valeurs de type <code>long</code>.
</p>
<p>
Plusieurs de ses méthodes reçoivent en argument ou retournent en résultat une heure de départ ou d'arrivée. Attention, ces heures sont exprimées en minutes écoulées depuis minuit (!) et ne sont valides que si elles sont comprises entre -240 (inclus) et 2880 (exclu). Ce n'est qu'au moment d'être empaquetées que ces minutes sont « translatées » afin d'être exprimées en fonction de l'origine choisie plus haut (-240). Cette « translation » garantit que les minutes empaquetées sont toujours positives, ce qui simplifie le code.
</p>
<p>
<code>PackedCriteria</code> offre les méthodes publiques (et statiques) suivantes :
</p>
<dl class="org-dl">
<dt><code>long pack(int arrMins, int changes, int payload)</code></dt><dd>qui retourne la valeur de type <code>long</code> résultant de l'empaquetage de l'heure d'arrivée, du nombre de changements et de la « charge utile » donnés, selon le format décrit à la §<a href="#sec/packed/criteria">2.2.5</a> — c.-à-d. sans heure (minutes) de départ — ou lève une <code>IllegalArgumentException</code> si l'heure d'arrivée est invalide, ou si le nombre de changements ne tient pas dans 7 bits,</dd>
<dt><code>boolean hasDepMins(long criteria)</code></dt><dd>qui retourne vrai ssi les critères empaquetés donnés incluent une heure de départ,</dd>
<dt><code>int depMins(long criteria)</code></dt><dd>qui retourne l'heure de départ (en minutes après minuit) des critères empaquetés donnés, ou lève <code>IllegalArgumentException</code> si ces critères n'incluent pas une heure de départ,</dd>
<dt><code>int arrMins(long criteria)</code></dt><dd>qui retourne l'heure d'arrivée (en minutes après minuit) des critères empaquetés donnés,</dd>
<dt><code>int changes(long criteria)</code></dt><dd>qui retourne le nombre de changements des critères empaquetés donnés,</dd>
<dt><code>int payload(long criteria)</code></dt><dd>qui retourne la « charge utile » associée aux critères empaquetés donnés,</dd>
<dt><code>boolean dominatesOrIsEqual(long criteria1, long criteria2)</code></dt><dd>qui retourne vrai si et seulement si les premiers critères empaquetés dominent ou sont égaux aux seconds, ou lève une <code>IllegalArgumentException</code> l'un des ensembles de critères possède une heure de départ mais l'autre pas,</dd>
<dt><code>long withoutDepMins(long criteria)</code></dt><dd>qui retourne des critères empaquetés identiques à ceux donnés, mais sans heure de départ,</dd>
<dt><code>long withDepMins(long criteria, int depMins1)</code></dt><dd>qui retourne des critères empaquetés identiques à ceux donnés, mais avec l'heure de départ donnée,</dd>
<dt><code>long withAdditionalChange(long criteria)</code></dt><dd>qui retourne des critères empaquetés identiques à ceux donnés, mais avec un changement de plus,</dd>
<dt><code>long withPayload(long criteria, int payload1)</code></dt><dd>qui retourne des critères empaquetés identiques à ceux donnés, mais avec la « charge utile » donnée.</dd>
</dl>
</div>
            </div>
        </div>
    
                    </div>
                </div>
        
    </div>
</body>
</html>
