<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Étape 3 - ReCHor Documentation</title>
    <style>
        :root {
            --primary-color: #1976D2;
            --secondary-color: #2196F3;
            --accent-color: #4CAF50;
            --background-color: #f5f5f5;
            --text-color: #333;
        }

        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            color: var(--text-color);
            background: var(--background-color);
        }

        .header {
            background: var(--primary-color);
            color: white;
            padding: 1rem 2rem;
            margin-bottom: 2rem;
            display: flex;
            align-items: center;
        }

        .header a {
            color: white;
            text-decoration: none;
            display: inline-block;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .header a:hover {
            background-color: rgba(255, 255, 255, 0.1);
            text-decoration: none;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        h2 {
            color: var(--primary-color);
            margin-top: 0;
        }

        .card-title {
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            margin: 0 0 1rem 0;
            color: var(--primary-color);
            font-size: 1.2rem;
        }

        .class-card, .concept-card {
            background: white;
            padding: 1.5rem;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: all 0.2s ease-in-out;
            margin-bottom: 1rem;
        }

        .class-card:hover, .concept-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .card-title {
            margin: 0 0 1rem 0;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #eee;
        }

        .card-title a {
            color: var(--primary-color);
            text-decoration: none;
            font-size: 1.2rem;
        }

        .card-title a:hover {
            color: var(--secondary-color);
        }

        .class-content, .concept-content {
            font-size: 0.95em;
            color: var(--text-color);
            overflow: auto;
            max-height: 500px;
            padding-right: 1rem;
        }

        .class-content p, .concept-content p {
            margin: 0.5rem 0;
        }

        .class-content pre, .concept-content pre {
            background: var(--background-color);
            padding: 1rem;
            border-radius: 4px;
            overflow-x: auto;
            margin: 1rem 0;
        }

        .class-grid, .concept-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 1.5rem;
            margin: 1rem 0;
        }

        .class-card .card-title {
            margin: 0;
        }

        .class-card, .concept-card {
            min-height: 100px;
            height: fit-content;
            display: flex;
            flex-direction: column;
            background: white;
            padding: 1.5rem;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }

        .concept-card {
            margin-bottom: 1rem;
        }

        .concept-card:hover, .class-card:hover {
            transform: translateY(-2px);
        }

        .concept-content {
            font-size: 0.95em;
            color: var(--text-color);
            overflow: auto;
            max-height: 300px;
            margin-top: 0.5rem;
        }

        .concept-content p {
            margin: 0.5rem 0;
        }

        .concept-content ol, .concept-content ul {
            margin: 0.5rem 0;
            padding-left: 1.5rem;
        }

        .concept-content a {
            color: var(--primary-color);
            text-decoration: none;
        }

        .concept-content a:hover {
            text-decoration: underline;
        }

        .concepts-section {
            margin: 2rem 0;
        }

        .concepts-section h3 {
            color: var(--primary-color);
            margin-bottom: 1rem;
        }

        .class-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            margin: 1rem 0;
        }

        .class-card a {
            text-decoration: none;
        }

        .introduction {
            background: white;
            padding: 2rem;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
        }

        .subtitle {
            font-style: italic;
            color: var(--secondary-color);
            margin: 1rem 0;
        }

        img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 1rem auto;
        }

        figure {
            margin: 2rem 0;
            text-align: center;
        }

        figcaption {
            font-style: italic;
            color: var(--text-color);
            margin-top: 0.5rem;
        }

        .concept-preview {
            color: var(--text-color);
            font-size: 0.9em;
            margin-top: 0.5rem;
            opacity: 0.8;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        .concept-card {
            min-height: 100px;
            height: fit-content;
            background: white;
            padding: 1.5rem;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: all 0.2s ease-in-out;
        }

        .concept-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .concept-card a {
            text-decoration: none;
            color: inherit;
            display: block;
            height: 100%;
        }
    </style>
</head>
<body>
    <header class="header">
        <a href="../index.html">← Retour à l'index</a>
    </header>
    <div class="container">
        <h2>Étape 3 - Horaire et frontière de Pareto</h2>
<p class="subtitle">ReCHor – étape 3</p>

            <div class="introduction">
                <div class="outline-text-2" id="text-1">
<p>
Le but de cette troisième étape est double : d'une part définir des interfaces représentant l'horaire de transport public et ses composants ; d'autre part, écrire une classe permettant de représenter ce que l'on nomme la frontière de Pareto, et qui joue un rôle crucial dans l'algorithme de recherche de voyages optimaux.
</p>
</div>
            </div>
        
                <div class="concepts-section">
                    <h3>Concepts clés</h3>
                    <div class="concept-grid">
            
        <div class="concept-card">
            <h3 class="card-title">
                <a href="../concepts/part3_horaire.html">Horaire</a>
            </h3>
            <div class="concept-preview">Les données horaires que nous utiliserons dans ce projet pour rechercher les voyages optimaux son...</div>
        </div>
    
        <div class="concept-card">
            <h3 class="card-title">
                <a href="../concepts/part3_frontiere_de_pareto.html">Frontière de Pareto</a>
            </h3>
            <div class="concept-preview">Nous avons vu à l'étape précédente que la recherche de voyages optimaux se fait en considérant tr...</div>
        </div>
    
        <div class="concept-card">
            <h3 class="card-title">
                <a href="../concepts/part3_representation_des_frontieres_immuables.html">Représentation des frontières immuables</a>
            </h3>
            <div class="concept-preview">L'algorithme de recherche de voyages optimaux que nous utiliserons calcule, étant donné un arrêt ...</div>
        </div>
    
        <div class="concept-card">
            <h3 class="card-title">
                <a href="../concepts/part3_representation_des_frontieres_non_immuables.html">Représentation des frontières non immuables</a>
            </h3>
            <div class="concept-preview">L'algorithme de recherche utilisé par ReCHor construit petit à petit les frontières de Pareto cor...</div>
        </div>
    
                    </div>
                </div>
        
                <div class="class-section">
                    <h3>Classes et Interfaces</h3>
                    <div class="class-grid">
        
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/Indexed.html">Indexed</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-3-1">
<p>
L'interface <code>Indexed</code>, du sous-paquetage <code>timetable</code>, est destinée à être étendue par toutes les interfaces représentant des données indexées. Par « données indexées » on entend toutes les données de l'horaire qui, conceptuellement en tout cas, sont stockées dans un tableau et identifiées par un index allant de 0 (inclus) à la taille du tableau (exclue).
</p>
<p>
<code>Indexed</code> ne possède qu'une seule méthode (publique et abstraite) :
</p>
<dl class="org-dl">
<dt><code>int size()</code></dt><dd>qui retourne la taille — c.-à-d. le nombre d'éléments — des données.</dd>
</dl>
</div>
            </div>
        </div>
    
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/Stations.html">Stations</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-3-2">
<p>
L'interface <code>Stations</code> du sous-paquetage <code>timetable</code>, publique et étendant <code>Indexed</code>, représente des gares indexées. Elle possède les méthodes abstraites suivantes :
</p>
<dl class="org-dl">
<dt><code>String name(int id)</code></dt><dd>qui retourne le nom de la gare d'index donné,</dd>
<dt><code>double longitude(int id)</code></dt><dd>qui retourne la longitude, en degrés, de la gare d'index donné,</dd>
<dt><code>double latitude(int id)</code></dt><dd>qui retourne la latitude, en degrés, de la gare d'index donné.</dd>
</dl>
<p>
Toutes ces méthodes lèvent une <code>IndexOutOfBoundsException</code> si l'index qu'on leur passe (nommé <code>id</code> ci-dessous) est invalide, c.-à-d. inférieur à 0 ou supérieur ou égal à la taille retournée par <code>size()</code>.
</p>
</div>
            </div>
        </div>
    
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/StationAliases.html">StationAliases</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-3-3">
<p>
L'interface <code>StationAliases</code> du sous-paquetage <code>timetable</code>, publique et étendant <code>Indexed</code>, représente les noms alternatifs des gares. Elle possède les méthodes abstraites suivantes :
</p>
<dl class="org-dl">
<dt><code>String alias(int id)</code></dt><dd>qui retourne le nom alternatif d'index donné (p. ex. <code>Losanna</code>),</dd>
<dt><code>String stationName(int id)</code></dt><dd>qui retourne le nom de la gare à laquelle correspond le nom alternatif d'index donné (p. ex. <code>Lausanne</code>).</dd>
</dl>
<p>
Toutes ces méthodes lèvent une <code>IndexOutOfBoundsException</code> si l'index qu'on leur passe (nommé <code>id</code> ci-dessous) est invalide, c.-à-d. inférieur à 0 ou supérieur ou égal à la taille retournée par <code>size()</code>.
</p>
</div>
            </div>
        </div>
    
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/Platforms.html">Platforms</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-3-4">
<p>
L'interface <code>Platforms</code> du sous-paquetage <code>timetable</code>, publique et étendant <code>Indexed</code>, représente des voies/quais indexés. Elle possède les méthodes abstraites suivantes :
</p>
<dl class="org-dl">
<dt><code>String name(int id)</code></dt><dd>qui retourne le nom de la voie (p. ex. <code>70</code>) ou du quai (p. ex. <code>A</code>), qui peut être vide,</dd>
<dt><code>int stationId(int id)</code></dt><dd>qui retourne l'index de la gare à laquelle cette voie ou ce quai appartient.</dd>
</dl>
<p>
Toutes ces méthodes lèvent une <code>IndexOutOfBoundsException</code> si l'index qu'on leur passe (nommé <code>id</code> ci-dessous) est invalide, c.-à-d. inférieur à 0 ou supérieur ou égal à la taille retournée par <code>size()</code>.
</p>
</div>
            </div>
        </div>
    
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/Routes.html">Routes</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-3-5">
<p>
L'interface <code>Routes</code> du sous-paquetage <code>timetable</code>, publique et étendant <code>Indexed</code>, représente des lignes de transport public indexées. Elle possède les méthodes abstraites suivantes :
</p>
<dl class="org-dl">
<dt><code>Vehicle vehicle(int id)</code></dt><dd>qui retourne le type de véhicule desservant la ligne d'index donné,</dd>
<dt><code>String name(int id)</code></dt><dd>qui retourne le nom de la ligne d'index donné (p. ex. IR 15).</dd>
</dl>
<p>
Toutes ces méthodes lèvent une <code>IndexOutOfBoundsException</code> si l'index qu'on leur passe (nommé <code>id</code> ci-dessous) est invalide, c.-à-d. inférieur à 0 ou supérieur ou égal à la taille retournée par <code>size()</code>.
</p>
</div>
            </div>
        </div>
    
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/Transfers.html">Transfers</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-3-6">
<p>
L'interface <code>Transfers</code> du sous-paquetage <code>timetable</code>, publique et étendant <code>Indexed</code>, représente des changements indexés. Il faut noter que, dans les données que nous utiliserons, des changements ne sont possibles qu'entre (ou au sein de) gares, et pas entre des voies ou quais.
</p>
<p>
<code>Transfers</code> possède les méthodes abstraites suivantes :
</p>
<dl class="org-dl">
<dt><code>int depStationId(int id)</code></dt><dd>qui retourne l'index de la gare de départ du changement d'index donné,</dd>
<dt><code>int minutes(int id)</code></dt><dd>qui retourne la durée, en minutes, du changement d'index donné,</dd>
<dt><code>int arrivingAt(int stationId)</code></dt><dd>qui retourne l'intervalle empaqueté — selon la convention utilisée par <code>PackedRange</code> — des index des changements dont la gare d'arrivée est celle d'index donné,</dd>
<dt><code>int minutesBetween(int depStationId, int arrStationId)</code></dt><dd>qui retourne la durée, en minutes, du changement entre les deux gares d'index donnés, ou lève <code>NoSuchElementException</code> si aucun changement n'est possible entre ces deux gares.</dd>
</dl>
<p>
Toutes ces méthodes lèvent une <code>IndexOutOfBoundsException</code> si l'un des index qu'on leur passe est invalide.
</p>
</div>
            </div>
        </div>
    
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/Trips.html">Trips</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-3-7">
<p>
L'interface <code>Trips</code> du sous-paquetage <code>timetable</code>, publique et étendant <code>Indexed</code>, représente des courses de transport public indexées. Elle possède les méthodes abstraites suivantes :
</p>
<dl class="org-dl">
<dt><code>int routeId(int id)</code></dt><dd>qui retourne l'index de la ligne à laquelle la course d'index donné appartient,</dd>
<dt><code>String destination(int id)</code></dt><dd>qui retourne le nom de la destination finale de la course.</dd>
</dl>
<p>
Toutes ces méthodes lèvent une <code>IndexOutOfBoundsException</code> si l'index qu'on leur passe (nommé <code>id</code> ci-dessous) est invalide, c.-à-d. inférieur à 0 ou supérieur ou égal à la taille retournée par <code>size()</code>.
</p>
</div>
            </div>
        </div>
    
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/Connections.html">Connections</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-3-8">
<p>
L'interface <code>Connections</code> du sous-paquetage <code>timetable</code>, publique et étendant <code>Indexed</code>, représente des liaisons indexées. Pour les besoins de l'algorithme de recherche de voyages, les liaisons doivent être ordonnées par heure de départ décroissante.
</p>
<p>
<code>Connections</code> possède les méthodes abstraites suivantes :
</p>
<dl class="org-dl">
<dt><code>int depStopId(int id)</code></dt><dd>qui retourne l'index de l'arrêt de départ de la liaison d'index donné,</dd>
<dt><code>int depMins(int id)</code></dt><dd>qui retourne l'heure de départ de la liaison d'index donné, exprimée en minutes après minuit,</dd>
<dt><code>int arrStopId(int id)</code></dt><dd>qui retourne l'index de l'arrêt d'arrivée de la liaison d'index donné,</dd>
<dt><code>int arrMins(int id)</code></dt><dd>qui retourne l'heure d'arrivée de la liaison d'index donné, exprimée en minutes après minuit,</dd>
<dt><code>int tripId(int id)</code></dt><dd>qui retourne l'index de la course à laquelle appartient la liaison d'index donné,</dd>
<dt><code>int tripPos(int id)</code></dt><dd>qui retourne la position de la liaison d'index donné dans la course à laquelle elle appartient, la première liaison d'une course ayant l'index 0,</dd>
<dt><code>int nextConnectionId(int id)</code></dt><dd>qui retourne l'index de la liaison suivant celle d'index donné dans la course à laquelle elle appartient, ou l'index de la première liaison de la course si la liaison d'index donné est la dernière de la course.</dd>
</dl>
<p>
Toutes ces méthodes lèvent une <code>IndexOutOfBoundsException</code> si l'index qu'on leur passe (nommé <code>id</code> ci-dessous) est invalide, c.-à-d. inférieur à 0 ou supérieur ou égal à la taille retournée par <code>size()</code>.
</p>
<p>
Les index des arrêts de départ et d'arrivée retournés par <code>depStopId</code> et <code>arrStopId</code> peuvent soit désigner des gares, soit des voies ou quais. Si un tel index est inférieur au nombre de gares existant dans l'horaire, alors il représente un index de gare. Sinon, il représente un index de voie ou de quai, qui peut être calculé en soustrayant de l'index d'arrêt le nombre de gares existant dans l'horaire.
</p>
<p>
Par exemple, s'il y a 1000 gares et 2000 voies ou quais, l'index d'arrêt 500 représente la gare d'index 500, tandis que l'index d'arrêt 1700 représente l'index de la voie/quai 700.
</p>
</div>
            </div>
        </div>
    
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/TimeTable.html">TimeTable</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-3-9">
<p>
L'interface <code>TimeTable</code> du sous-paquetage <code>timetable</code>, publique, représente un horaire de transport public. Elle possède les méthodes abstraites suivantes :
</p>
<dl class="org-dl">
<dt><code>Stations stations()</code></dt><dd>qui retourne les gares indexées de l'horaire,</dd>
<dt><code>StationAliases stationAliases()</code></dt><dd>qui retourne les noms alternatifs indexés des gares de l'horaire,</dd>
<dt><code>Platforms platforms()</code></dt><dd>qui retourne les voies/quais indexées de l'horaire,</dd>
<dt><code>Routes routes()</code></dt><dd>qui retourne les lignes indexées de l'horaire,</dd>
<dt><code>Transfers transfers()</code></dt><dd>qui retourne les changements indexés de l'horaire,</dd>
<dt><code>Trips tripsFor(LocalDate date)</code></dt><dd>qui retourne les courses indexées de l'horaire actives le jour donné,</dd>
<dt><code>Connections connectionsFor(LocalDate date)</code></dt><dd>qui retourne les liaisons indexées de l'horaire actives le jour donné.</dd>
</dl>
<p>
En plus de ces méthodes abstraites, <code>TimeTable</code> possède également les méthodes par défaut suivantes :
</p>
<dl class="org-dl">
<dt><code>default boolean isStationId(int stopId)</code></dt><dd>qui retourne vrai si et seulement si l'index d'arrêt donné est un index de gare (et pas un index de voie ou de quai),</dd>
<dt><code>default boolean isPlatformId(int stopId)</code></dt><dd>qui retourne vrai si et seulement si l'index d'arrêt donné est un index de voie ou de quai (et pas un index de gare),</dd>
<dt><code>default int stationId(int stopId)</code></dt><dd>qui retourne l'index de la gare de l'arrêt d'index donné (qui peut être identique si l'arrêt en question est une gare),</dd>
<dt><code>default String platformName(int stopId)</code></dt><dd>qui retourne le nom de voie ou de quai de l'arrêt d'index donné, ou <code>null</code> si cet arrêt est une gare.</dd>
</dl>
</div>
            </div>
        </div>
    
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/ParetoFront.html">ParetoFront</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-3-10">
<p>
La classe <code>ParetoFront</code> du sous-paquetage <code>journey</code>, publique et immuable, représente une frontière de Pareto de critères d'optimisation. Les tuples de la frontière sont stockés sous forme empaquetée, dans un tableau de type <code>long[]</code> privé.
</p>
<p>
<code>ParetoFront</code> possède l'attribut public, statique et final suivant :
</p>
<dl class="org-dl">
<dt><code>ParetoFront EMPTY</code></dt><dd>qui contient une frontière de Pareto vide.</dd>
</dl>
<p>
<code>ParetoFront</code> ne possède pas de constructeur public, car ses instances ne sont destinées à être construites que par le bâtisseur décrit à la section suivante. Elle possède toutefois un constructeur privé qui prend en argument un tableau de type <code>long[]</code> contenant les critères empaquetés, qu'elle stocke <i>sans</i> le copier. Pour garantir l'immuabilité de la classe, il est donc fondamental que ce tableau ne change pas après l'appel du constructeur. En particulier, la méthode <code>build</code> du bâtisseur décrit plus bas doit garantir cela, en passant au constructeur une copie de son tableau interne.
</p>
<p>
En plus de ce constructeur privé, <code>ParetoFront</code> offre les méthodes publiques suivantes :
</p>
<dl class="org-dl">
<dt><code>int size()</code></dt><dd>qui retourne la taille de la frontière de Pareto, c.-à-d. le nombre de tuples (paires ou triplets de critères d'optimisation) qu'elle contient,</dd>
<dt><code>long get(int arrMins, int changes)</code></dt><dd>qui retourne les critères d'optimisation empaquetés dont l'heure d'arrivée et le nombre de changements sont ceux donnés, ou lève une <code>NoSuchElementException</code> si ces critères ne font pas partie de la frontière,</dd>
<dt><code>void forEach(LongConsumer action)</code></dt><dd>qui appelle la méthode <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/LongConsumer.html#accept(long)"><code>accept</code></a> de l'action de type <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/LongConsumer.html"><code>LongConsumer</code></a> donnée avec chacun des critères de la frontière, dans l'ordre.</dd>
</dl>
<p>
En plus de ces méthodes, il est <i>très fortement</i> conseillé d'ajouter à <code>ParetoFront</code> une redéfinition de la méthode <code>toString</code> qui produit une représentation textuelle de la frontière de Pareto, afin de faciliter le débogage. Le format de cette représentation textuelle n'est pas spécifié, mais il est conseillé de présenter les critères de la frontière de manière aussi lisible que possible, en montrant pour chacun d'eux l'heure de départ (si elle est présente), l'heure d'arrivée et le nombre de changements.
</p>
</div>
            </div>
        </div>
    
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/ParetoFront.Builder.html">ParetoFront.Builder</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-3-11">
<p>
La classe <code>Builder</code> imbriquée statiquement dans <code>ParetoFront</code>, publique, représente un bâtisseur de frontière de Pareto. La frontière en cours de construction est stockée dans un tableau de type <code>long[]</code> qui contient les tuples et est « redimensionné » au besoin selon la technique décrite dans les conseils de programmation plus bas.
</p>
<p>
<code>Builder</code> offre deux constructeurs publics :
</p>
<dl class="org-dl">
<dt><code>Builder()</code></dt><dd>qui retourne un bâtisseur dont la frontière en cours de construction est vide,</dd>
<dt><code>Builder(Builder that)</code></dt><dd>qui retourne un nouveau bâtisseur avec les mêmes attributs que celui reçu en argument (constructeur de copie).</dd>
</dl>
<p>
En plus de ces constructeurs, <code>Builder</code> offre les méthodes publiques ci-dessous, toutes celles modifiant la frontière retournent le bâtisseur lui-même afin de permettre le chaînage des appels :
</p>
<dl class="org-dl">
<dt><code>boolean isEmpty()</code></dt><dd>qui retourne vrai si et seulement si la frontière en cours de construction est vide,</dd>
<dt><code>Builder clear()</code></dt><dd>qui vide la frontière en cours de construction en supprimant tous ses éléments,</dd>
<dt><code>Builder add(long packedTuple)</code></dt><dd>qui ajoute à la frontière le tuple de critères empaquetés donné ; cet ajout n'est fait que si le nouveau tuple n'est pas dominé ou égal à un de la frontière, et tous les éventuels tuples existants et dominés par le nouveau en sont supprimés,</dd>
<dt><code>Builder add(int arrMins, int changes, int payload)</code></dt><dd>qui ajoute à la frontière un tuple de critères augmentés ayant l'heure d'arrivée, le nombre de changements et la charge utile donnés, mais pas d'heure de départ ; l'ajout est fait de la même manière que dans la méthode précédente,</dd>
<dt><code>Builder addAll(Builder that)</code></dt><dd>qui ajoute à la frontière tous les tuples présents dans la frontière en cours de construction par le bâtisseur donné,</dd>
<dt><code>boolean fullyDominates(Builder that, int depMins)</code></dt><dd>qui retourne vrai si et seulement si chacun des tuples de la frontière donnée, une fois son heure de départ fixée sur celle donnée, est dominé par, ou égal à, au moins un tuple du récepteur (le récepteur étant l'objet auquel on applique la méthode),</dd>
<dt><code>void forEach(LongConsumer action)</code></dt><dd>qui fait la même chose que la méthode <code>forEach</code> de <code>ParetoFront</code>,</dd>
<dt><code>ParetoFront build()</code></dt><dd>qui retourne la frontière de Pareto en cours de construction par ce bâtisseur.</dd>
</dl>
<p>
Tout comme pour <code>ParetoFront</code>, il est très fortement conseillé d'ajouter à <code>Builder</code> une redéfinition de la méthode <code>toString</code> afin de faciliter le débogage. La plupart du code peut être partagée entre les deux méthodes <code>toString</code>.
</p>
</div>
            </div>
        </div>
    
                    </div>
                </div>
        
    </div>
</body>
</html>
