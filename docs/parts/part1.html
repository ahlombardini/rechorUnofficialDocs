<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Étape 1 - ReCHor Documentation</title>
    <style>
        :root {
            --primary-color: #1976D2;
            --secondary-color: #2196F3;
            --accent-color: #4CAF50;
            --background-color: #f5f5f5;
            --text-color: #333;
        }

        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            color: var(--text-color);
            background: var(--background-color);
        }

        .header {
            background: var(--primary-color);
            color: white;
            padding: 1rem 2rem;
            margin-bottom: 2rem;
            display: flex;
            align-items: center;
        }

        .header a {
            color: white;
            text-decoration: none;
            display: inline-block;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .header a:hover {
            background-color: rgba(255, 255, 255, 0.1);
            text-decoration: none;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        h2 {
            color: var(--primary-color);
            margin-top: 0;
        }

        .card-title {
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            margin: 0 0 1rem 0;
            color: var(--primary-color);
            font-size: 1.2rem;
        }

        .class-card, .concept-card {
            background: white;
            padding: 1.5rem;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: all 0.2s ease-in-out;
            margin-bottom: 1rem;
        }

        .class-card:hover, .concept-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .card-title {
            margin: 0 0 1rem 0;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #eee;
        }

        .card-title a {
            color: var(--primary-color);
            text-decoration: none;
            font-size: 1.2rem;
        }

        .card-title a:hover {
            color: var(--secondary-color);
        }

        .class-content, .concept-content {
            font-size: 0.95em;
            color: var(--text-color);
            overflow: auto;
            max-height: 500px;
            padding-right: 1rem;
        }

        .class-content p, .concept-content p {
            margin: 0.5rem 0;
        }

        .class-content pre, .concept-content pre {
            background: var(--background-color);
            padding: 1rem;
            border-radius: 4px;
            overflow-x: auto;
            margin: 1rem 0;
        }

        .class-grid, .concept-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 1.5rem;
            margin: 1rem 0;
        }

        .class-card .card-title {
            margin: 0;
        }

        .class-card, .concept-card {
            min-height: 100px;
            height: fit-content;
            display: flex;
            flex-direction: column;
            background: white;
            padding: 1.5rem;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }

        .concept-card {
            margin-bottom: 1rem;
        }

        .concept-card:hover, .class-card:hover {
            transform: translateY(-2px);
        }

        .concept-content {
            font-size: 0.95em;
            color: var(--text-color);
            overflow: auto;
            max-height: 300px;
            margin-top: 0.5rem;
        }

        .concept-content p {
            margin: 0.5rem 0;
        }

        .concept-content ol, .concept-content ul {
            margin: 0.5rem 0;
            padding-left: 1.5rem;
        }

        .concept-content a {
            color: var(--primary-color);
            text-decoration: none;
        }

        .concept-content a:hover {
            text-decoration: underline;
        }

        .concepts-section {
            margin: 2rem 0;
        }

        .concepts-section h3 {
            color: var(--primary-color);
            margin-bottom: 1rem;
        }

        .class-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            margin: 1rem 0;
        }

        .class-card a {
            text-decoration: none;
        }

        .introduction {
            background: white;
            padding: 2rem;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
        }

        .subtitle {
            font-style: italic;
            color: var(--secondary-color);
            margin: 1rem 0;
        }

        img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 1rem auto;
        }

        figure {
            margin: 2rem 0;
            text-align: center;
        }

        figcaption {
            font-style: italic;
            color: var(--text-color);
            margin-top: 0.5rem;
        }

        .concept-preview {
            color: var(--text-color);
            font-size: 0.9em;
            margin-top: 0.5rem;
            opacity: 0.8;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        .concept-card {
            min-height: 100px;
            height: fit-content;
            background: white;
            padding: 1.5rem;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: all 0.2s ease-in-out;
        }

        .concept-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .concept-card a {
            text-decoration: none;
            color: inherit;
            display: block;
            height: 100%;
        }
    </style>
</head>
<body>
    <header class="header">
        <a href="../index.html">← Retour à l'index</a>
    </header>
    <div class="container">
        <h2>Étape 1 - Mise en place</h2>
<p class="subtitle">ReCHor – étape 1</p>

            <div class="introduction">
                <div class="outline-text-2" id="text-1">
<p>
Le but de cette première étape est d'écrire des classes et interfaces représentant quelques concepts importants du projet — les arrêts de transport public, les voyages (relations), etc. — ainsi que le code permettant de les représenter sous forme textuelle.
</p>
<p>
Comme toutes les descriptions d'étapes, celle-ci commence par une introduction aux concepts nécessaires à sa réalisation (§<a href="#sec/concepts">2</a>), suivie d'une présentation de leur mise en œuvre en Java (§<a href="#sec/implementation">3</a>).
</p>
<p>
Si vous travaillez en groupe, vous êtes toutefois priés de lire, avant de continuer, les guides <a href="../g/group-work.html"><i>Travailler en groupe</i></a> et <a href="../g/sync.html"><i>Synchroniser son travail</i></a>, qui vous aideront à bien vous organiser.
</p>
</div>
            </div>
        
                <div class="concepts-section">
                    <h3>Concepts clés</h3>
                    <div class="concept-grid">
            
        <div class="concept-card">
            <h3 class="card-title">
                <a href="../concepts/part1_arrt.html">Arrêt</a>
            </h3>
            <div class="concept-preview">Un arrêt (stop en anglais) est un endroit où un véhicule de transport public peut s'arrêter afin ...</div>
        </div>
    
        <div class="concept-card">
            <h3 class="card-title">
                <a href="../concepts/part1_ligne.html">Ligne</a>
            </h3>
            <div class="concept-preview">Un véhicule de transport public se déplace toujours en suivant une ligne (route), p. ex. la ligne...</div>
        </div>
    
        <div class="concept-card">
            <h3 class="card-title">
                <a href="../concepts/part1_voyage.html">Voyage</a>
            </h3>
            <div class="concept-preview">Nous nommerons voyage (journey) un déplacement entre deux arrêts de transports publics. Un voyage...</div>
        </div>
    
        <div class="concept-card">
            <h3 class="card-title">
                <a href="../concepts/part1_representation_textuelle.html">Représentation textuelle</a>
            </h3>
            <div class="concept-preview">Plusieurs des concepts décrits ci-dessus, par exemple les étapes d'un voyage, doivent pouvoir êtr...</div>
        </div>
    
                    </div>
                </div>
        
                <div class="class-section">
                    <h3>Classes et Interfaces</h3>
                    <div class="class-grid">
        
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/Preconditions.html">Preconditions</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-3-3">
<p>
Fréquemment, les méthodes d'un programme exigent que leurs arguments satisfassent certaines conditions. Par exemple, une méthode déterminant la valeur maximale d'un tableau d'entiers exige que ce tableau contienne au moins un élément.
</p>
<p>
De telles conditions sont souvent appelées <b>préconditions</b> (<i>preconditions</i>) car elles doivent être satisfaites <i>avant</i> l'appel d'une méthode : c'est à l'appelant de s'assurer qu'il n'appelle la méthode qu'avec des arguments valides.
</p>
<p>
En Java, la convention veut que chaque méthode vérifie, autant que possible, ses préconditions et lève une exception — souvent <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/IllegalArgumentException.html"><code>IllegalArgumentException</code></a> — si l'une d'entre elles n'est pas satisfaite. Par exemple, une méthode <code>max</code> calculant la valeur maximale d'un tableau d'entiers, et exigeant logiquement que celui-ci contienne au moins un élément, pourrait commencer ainsi :
</p>
<div class="org-src-container">
<pre class="src src-java">int max(int[] array) {
  if (! (array.length &gt; 0))
    throw new IllegalArgumentException();
  // … reste du code
}
</pre>
</div>
<p>
(Notez au passage que la méthode <code>max</code> ne déclare <i>pas</i> qu'elle lève potentiellement <code>IllegalArgumentException</code> au moyen d'une clause <code>throws</code>, car cette exception est de type <i>unchecked</i>.)
</p>
<p>
La première classe à réaliser dans le cadre de ce projet a pour but de faciliter l'écriture de telles préconditions. En l'utilisant, la méthode ci-dessus pourrait être simplifiée ainsi :
</p>
<div class="org-src-container">
<pre class="src src-java">int max(int[] array) {
  Preconditions.checkArgument(array.length &gt; 0);
  // … reste du code
}
</pre>
</div>
<p>
Cette classe est nommée <code>Preconditions</code> et appartient au paquetage principal. Elle est publique et finale et n'offre rien d'autre que la méthode <code>checkArgument</code> décrite plus bas. Elle a toutefois la particularité d'avoir un constructeur par défaut privé :
</p>
<div class="org-src-container">
<pre class="src src-java">public final class Preconditions {
  private Preconditions() {}
  // … méthode(s)
}
</pre>
</div>
<p>
Le but de ce constructeur privé est de rendre impossible la création d'instances de la classe, puisque cela n'a clairement aucun sens — elle ne sert que de conteneur à une méthode statique. Dans la suite du projet, nous définirons plusieurs autres classes du même type, que nous appellerons dès maintenant classes <b>non instanciables</b>.
</p>
<p>
La méthode publique (et statique) offerte par la classe <code>Preconditions</code> est :
</p>
<dl class="org-dl">
<dt><code>void checkArgument(boolean shouldBeTrue)</code></dt><dd>qui lève l'exception <code>IllegalArgumentException</code> si son argument est faux, et ne fait rien sinon.</dd>
</dl>
</div>
            </div>
        </div>
    
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/s Java.html">s Java</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-3-5">
<p>
Avant de décrire <code>Stop</code>, la prochaine classe à mettre en œuvre pour cette étape, il convient de décrire le concept de <b>classe enregistrement</b> (<i>record class</i>), ou simplement <b>enregistrement</b> (<i>record</i>), introduit dans la version 17 de Java.
</p>
<p>
Un enregistrement est un type particulier de classe qui peut se définir au moyen d'une syntaxe plus concise qu'une classe normale. Dans cette syntaxe, le mot-clef <code>class</code> est remplacé par <code>record</code> et les attributs de la classe sont donnés entre parenthèses, après son nom.
</p>
<p>
Par exemple, un enregistrement nommé <code>Complex</code> représentant un nombre complexe dont les attributs sont sa partie réelle <code>re</code> et sa partie imaginaire <code>im</code> — tous deux de type <code>double</code> — peut se définir ainsi :
</p>
<div class="org-src-container">
<pre class="src src-java">public record Complex(double re, double im) { }
</pre>
</div>
<p>
Cette définition est équivalente à celle d'une classe finale (!) dotée de :
</p>
<ul class="org-ul">
<li>deux attributs privés et finaux nommés <code>re</code> et <code>im</code> de type <code>double</code>,</li>
<li>un constructeur prenant en argument la valeur de ces attributs et les initialisant,</li>
<li>des méthodes d'accès (<i>getters</i>) publics nommés <code>re()</code> et <code>im()</code> pour ces attributs,</li>
<li>une méthode <code>equals</code> retournant vrai si et seulement si l'objet qu'on lui passe est aussi une instance de <code>Complex</code> et que ses attributs sont égaux à ceux de <code>this</code>,</li>
<li>une méthode <code>hashCode</code> compatible avec la méthode <code>equals</code> — le but de cette méthode et la signification de sa compatibilité avec <code>equals</code> seront examinés ultérieurement dans le cours,</li>
<li>une méthode <code>toString</code> retournant une chaîne composée du nom de la classe et du nom et de la valeur des attributs de l'instance, p. ex. <code>Complex[re=1.0, im=2.0]</code>.</li>
</ul>
<p>
En d'autres termes, la définition plus haut, qui tient sur une ligne, est équivalente à la définition suivante, qui n'utilise que des concepts que vous connaissez déjà :
</p>
<div class="org-src-container">
<pre class="src src-java">public final class Complex {
  private final double re;
  private final double im;

  public Complex(double re, double im) {
    this.re = re;
    this.im = im;
  }

  public double re() { return re; }
  public double im() { return im; }

  @Override
  public boolean equals(Object that) {
    // … vrai ssi that :
    // 1. est aussi une instance de Complex, et
    // 2. ses attributs re et im sont identiques.
  }

  @Override
  public int hashCode() {
    // … code omis car peu important
  }

  @Override
  public String toString() {
    return "Complex[re=" + re + ", im=" + im + "]";
  }
}
</pre>
</div>
<p>
Comme cet exemple l'illustre, les enregistrements permettent d'éviter d'écrire beaucoup de code répétitif, ce que les anglophones appellent du <a href="https://en.wikipedia.org/wiki/Boilerplate_code"><i>boilerplate code</i></a>. Il faut toutefois bien comprendre qu'en dehors d'une syntaxe très concise, les enregistrements n'apportent — pour l'instant en tout cas — rien de nouveau à Java, dans le sens où il est toujours possible de récrire un enregistrement en une classe Java équivalente, comme ci-dessus. En cela, les enregistrements sont similaires aux types énumérés.
</p>
<p>
Il est bien entendu possible de définir des méthodes dans un enregistrement, qui viennent s'ajouter à celles définies automatiquement. Par exemple, pour doter l'enregistrement <code>Complex</code> d'une méthode <code>modulus</code> retournant son module, il suffit de l'ajouter entre les accolades, ainsi :
</p>
<div class="org-src-container">
<pre class="src src-java">public record Complex(double re, double im) {
  public double modulus() { return Math.hypot(re, im); }
}
</pre>
</div>
<p>
(La méthode <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Math.html#hypot(double,double)"><code>Math.hypot(x,y)</code></a> retourne \(\sqrt{x^2 + y^2}\)).
</p>
<p>
Finalement, il est aussi possible de définir ce que l'on nomme un <b>constructeur compact</b> (<i>compact constructor</i>), qui augmente le constructeur que Java ajoute par défaut aux enregistrements. Un constructeur compact doit son nom au fait qu'il semble ne prendre aucun argument, et n'initialise pas explicitement les attributs. En réalité, il prend des arguments qui sont les mêmes que ceux de l'enregistrement (<code>re</code> et <code>im</code> dans notre exemple), et Java lui ajoute automatiquement des affectations de ces arguments aux attributs correspondants.
</p>
<p>
Par exemple, on pourrait vouloir ajouter un constructeur compact à la classe <code>Complex</code> pour lever une exception si l'un des arguments passés au constructeur était une valeur <code>NaN</code> (<i>not a number</i>, une valeur invalide). On pourrait le faire ainsi :
</p>
<div class="org-src-container">
<pre class="src src-java">public record Complex(double re, double im) {
  public Complex {  // constructeur compact
    if (Double.isNaN(re) || Double.isNaN(im))
      throw new IllegalArgumentException();
  }
  // … méthode modulus
}
</pre>
</div>
<p>
Ce constructeur compact serait automatiquement traduit en :
</p>
<div class="org-src-container">
<pre class="src src-java">public final class Complex {
  // … attributs re et im

  public Complex(double re, double im) {
    if (Double.isNaN(re) || Double.isNaN(im))
      throw new IllegalArgumentException();
    this.re = re;  // ajouté automatiquement
    this.im = im;  // ajouté automatiquement
  }

  // … méthodes modulus, re, im, hashCode, etc.
}
</pre>
</div>
<p>
Les enregistrements ne seront pas décrits en détail dans le cours, mais seront introduits au moyen d'exemples similaires à ceux ci-dessus dans la suite du projet. Les personnes intéressées par les détails de leur fonctionnement pourront se rapporter à la <a href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.10">§8.10 (<i>Record Classes</i>) de la spécification du langage</a>.
</p>
</div>
            </div>
        </div>
    
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/Stop.html">Stop</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-3-6">
<p>
L'enregistrement <code>Stop</code> du sous-paquetage <code>journey</code>, public, représente un
arrêt de transport public. Cet enregistrement est utilisé à la fois pour les gares et pour les voies ou quais. Il possède les attributs suivants :
</p>
<dl class="org-dl">
<dt><code>String name</code></dt><dd>le nom de l'arrêt, ou le nom de la gare à laquelle appartient l'arrêt s'il représente une voie ou un quai,</dd>
<dt><code>String platformName</code></dt><dd>le nom de la voie ou du quai de l'arrêt, ou <code>null</code> si l'arrêt correspond à une gare,</dd>
<dt><code>double longitude</code></dt><dd>la longitude de la position de l'arrêt, en degrés,</dd>
<dt><code>double latitude</code></dt><dd>la latitude de la position de l'arrêt, en degrés.</dd>
</dl>
<p>
Par exemple, l'arrêt correspondant à la gare de Lausanne pourrait être construit ainsi :
</p>
<div class="org-src-container">
<pre class="src src-java">Stop l = new Stop("Lausanne", null, 6.62909, 46.51679);
</pre>
</div>
<p>
tandis que celui correspondant à la voie 70 de cette même gare pourrait l'être ainsi :
</p>
<div class="org-src-container">
<pre class="src src-java">Stop l70 = new Stop("Lausanne", "70", 6.62909, 46.51679);
</pre>
</div>
<p>
<code>Stop</code> possède un constructeur compact chargé de valider les arguments et qui :
</p>
<ul class="org-ul">
<li>lève une <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/NullPointerException.html"><code>NullPointerException</code></a> si <code>name</code> est <code>null</code>, ou</li>
<li>lève une <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/IllegalArgumentException.html"><code>IllegalArgumentException</code></a> si <code>longitude</code> n'est pas compris entre ±180° (inclus) ou si <code>latitude</code> n'est pas compris entre ±90° (inclus).</li>
</ul>
<p>
<code>Stop</code> ne possède aucune autre méthode que celles ajoutées automatiquement aux enregistrements par Java.
</p>
</div>
            </div>
        </div>
    
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/Journey.html">Journey</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-3-7">
<p>
L'enregistrement <code>Journey</code>, du sous-paquetage <code>journey</code>, public et immuable, représente un voyage. Il possède un unique attribut :
</p>
<dl class="org-dl">
<dt><code>List&lt;Leg&gt; legs</code></dt><dd>les étapes du voyage.</dd>
</dl>
<p>
Le type <code>Leg</code> est celui d'une interface imbriquée à l'intérieur de l'enregistrement <code>Journey</code> et décrite à la §<a href="#sec/java/leg">3.8</a>. Comme expliqué dans cette section et celles qui suivent, trois enregistrements (<code>IntermediateStop</code>, <code>Transport</code> et <code>Foot</code>) sont imbriqués dans <code>Leg</code>. Cela signifie que <code>Journey</code> a la structure suivante :
</p>
<div class="org-src-container">
<pre class="src src-java">public record Journey(/* … attributs */) {
  public interface Leg {
    public record IntermediateStop(/* … attributs */) {
      /* … constructeur et/ou méthodes */
    }
    /* … autres enregistrements imbriqués, méthodes */
  }
  /* … constructeur et/ou méthodes */
}
</pre>
</div>
<p>
En raison de cette imbrication, la notation pointée doit être utilisée depuis l'extérieur pour accéder à l'interface <code>Leg</code> et aux enregistrements <code>IntermediateStop</code>, <code>Transport</code> et <code>Foot</code>. Par exemple, pour créer une instance de l'enregistrement <code>IntermediateStop</code>, on écrira :
</p>
<div class="org-src-container">
<pre class="src src-java">new Journey.Leg.IntermediateStop(/* … arguments */);
</pre>
</div>
<p>
<code>Journey</code> possède un constructeur compact qui valide la liste des étapes reçue  en vérifiant que :
</p>
<ul class="org-ul">
<li>elle n'est pas vide,</li>
<li>les étapes à pied alternent avec celles en transport,</li>
<li>pour toutes les étapes sauf la première, l'instant de départ ne précède pas celui d'arrivée de la précédente,</li>
<li>pour toutes les étapes sauf la première, l'arrêt de départ est identique à l'arrêt d'arrivée de la précédente.</li>
</ul>
<p>
Si l'une de ces conditions n'est pas satisfaite, le constructeur compact lève une <code>IllegalArgumentException</code>. Sinon, dans le but de garantir l'immuabilité de la classe, il copie la liste des étapes en utilisant la technique décrite dans les conseils de programmation plus bas.
</p>
<p>
<code>Journey</code> offre les méthodes publiques suivantes :
</p>
<dl class="org-dl">
<dt><code>Stop depStop()</code></dt><dd>qui retourne l'arrêt de départ du voyage, c.-à-d. celui de sa première étape,</dd>
<dt><code>Stop arrStop()</code></dt><dd>qui retourne l'arrêt d'arrivée du voyage, c.-à-d. celui de sa dernière étape,</dd>
<dt><code>LocalDateTime depTime()</code></dt><dd>qui retourne la date/heure de début du voyage, c.-à-d. celle de sa première étape,</dd>
<dt><code>LocalDateTime arrTime()</code></dt><dd>qui retourne la date/heure de fin du voyage, c.-à-d. celle de sa dernière étape,</dd>
<dt><code>Duration duration()</code></dt><dd>qui retourne la durée totale du voyage, c.-à-d. celle séparant la date/heure de fin de celle de début.</dd>
</dl>
<p>
La classe <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/time/LocalDateTime.html"><code>LocalDateTime</code></a>, qui représente un couple date/heure sans indication de fuseau horaire, fait partie de la bibliothèque Java. Cette classe jouera un rôle très important dans ce projet, et il est donc conseillé de prendre un moment pour lire <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/time/LocalDateTime.html">sa documentation</a>.
</p>
</div>
            </div>
        </div>
    
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/Journey.Leg.html">Journey.Leg</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-sec/java/leg">
<p>
L'interface <code>Leg</code>, publique et imbriquée dans l'enregistrement <code>Journey</code>, représente une étape d'un voyage. Cette interface est implémentée par deux enregistrements, <code>Transport</code> (décrit à la §<a href="#sec/java/transport">3.10</a>) et <code>Foot</code> (décrit à la §<a href="#sec/java/foot">3.11</a>), qui correspondent aux deux types d'étapes — en transport et à pied.
</p>
<p>
L'interface <code>Leg</code> offre les méthodes suivantes, toutes abstraites sauf la dernière :
</p>
<dl class="org-dl">
<dt><code>Stop depStop()</code></dt><dd>qui retourne l'arrêt de départ de l'étape,</dd>
<dt><code>LocalDateTime depTime()</code></dt><dd>qui retourne la date/heure de départ de l'étape,</dd>
<dt><code>Stop arrStop()</code></dt><dd>qui retourne l'arrêt d'arrivée de l'étape,</dd>
<dt><code>LocalDateTime arrTime()</code></dt><dd>qui retourne la date/heure d'arrivée de l'étape,</dd>
<dt><code>List&lt;IntermediateStop&gt; intermediateStops()</code></dt><dd>qui retourne la liste des arrêts intermédiaires de l'étape, le type <code>IntermediateStop</code> étant décrit à la §<a href="#sec/java/intermediate-stop">3.9</a>,</dd>
<dt><code>default Duration duration()</code></dt><dd>qui retourne la durée de l'étape.</dd>
</dl>
<p>
La classe <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/time/Duration.html"><code>Duration</code></a>, qui représente une durée, est une classe de la bibliothèque Java qui provient du même paquetage que <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/time/LocalDateTime.html"><code>LocalDateTime</code></a> (<code>java.time</code>). La lecture de <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/time/Duration.html">sa documentation</a> est aussi fortement recommandée.
</p>
</div>
            </div>
        </div>
    
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/Journey.Leg.IntermediateStop.html">Journey.Leg.IntermediateStop</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-sec/java/intermediate-stop">
<p>
L'enregistrement <code>IntermediateStop</code>, public et imbriqué dans l'interface <code>Leg</code>, représente un arrêt intermédiaire d'une étape. Il s'agit d'un arrêt auquel le moyen de transport utilisé s'arrête effectivement, mais qui se trouve entre l'arrêt de départ et l'arrêt d'arrivée de l'étape. Cet enregistrement possède les attributs suivants :
</p>
<dl class="org-dl">
<dt><code>Stop stop</code></dt><dd>l'arrêt intermédiaire en question,</dd>
<dt><code>LocalDateTime arrTime</code></dt><dd>la date/heure d'arrivée à l'arrêt,</dd>
<dt><code>LocalDateTime depTime</code></dt><dd>la date/heure de départ de l'arrêt.</dd>
</dl>
<p>
<code>IntermediateStop</code> possède un constructeur compact qui valide les arguments en vérifiant que :
</p>
<ul class="org-ul">
<li><code>stop</code> n'est pas <code>null</code> (avec <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Objects.html#requireNonNull(T)"><code>requireNonNull</code></a>),</li>
<li>la date/heure de départ n'est pas antérieure à celle d'arrivée (attention, les deux peuvent être égales !).</li>
</ul>
<p>
Notez que, comme il s'agit d'un arrêt intermédiaire, le véhicule y arrive avant d'en repartir, raison pour laquelle la date/heure d'arrivée doit précéder (ou être identique à) celle de départ.
</p>
<p>
Comme d'habitude, une <code>NullPointerException</code> est levée si la première vérification échoue, et une <code>IllegalArgumentException</code> si la seconde échoue.
</p>
</div>
            </div>
        </div>
    
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/Journey.Leg.Transport.html">Journey.Leg.Transport</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-sec/java/transport">
<p>
L'enregistrement <code>Transport</code>, public et imbriqué dans l'interface <code>Leg</code>, représente une étape effectuée en transport public. Il implémente donc <code>Leg</code> et possède les attributs suivants :
</p>
<dl class="org-dl">
<dt><code>Stop depStop</code></dt><dd>l'arrêt de départ de l'étape,</dd>
<dt><code>LocalDateTime depTime</code></dt><dd>la date/heure de départ de l'étape,</dd>
<dt><code>Stop arrStop</code></dt><dd>l'arrêt d'arrivée de l'étape,</dd>
<dt><code>LocalDateTime arrTime</code></dt><dd>la date/heure d'arrivée de l'étape,</dd>
<dt><code>List&lt;IntermediateStop&gt; intermediateStops</code></dt><dd>les éventuels arrêts intermédiaires de l'étape,</dd>
<dt><code>Vehicle vehicle</code></dt><dd>le type de véhicule utilisé pour cette étape,</dd>
<dt><code>String route</code></dt><dd>le nom de la ligne sur laquelle circule le véhicule utilisé pour cette étape,</dd>
<dt><code>String destination</code></dt><dd>le nom de la destination finale du véhicule utilisé pour cette étape.</dd>
</dl>
<p>
Le constructeur compact de <code>Transport</code> valide les arguments en vérifiant que :
</p>
<ul class="org-ul">
<li>aucun d'entre eux n'est <code>null</code>,</li>
<li>la date/heure d'arrivée n'est pas antérieure à celle de départ.</li>
</ul>
<p>
De plus, il copie la liste des arrêts intermédiaires afin de garantir l'immuabilité de la classe.
</p>
<p>
<code>Transport</code> ne possède aucune autre méthode que celles ajoutées automatiquement aux enregistrements par Java. Notez que ces méthodes ajoutées par Java sont celles qui implémentent les méthodes abstraites de l'interface <code>Leg</code>. Par exemple, la méthode d'accès pour l'attribut <code>depStop</code>, ajoutée automatiquement, implémente la méthode <code>depStop()</code> de <code>Leg</code>.
</p>
</div>
            </div>
        </div>
    
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/Journey.Leg.Foot.html">Journey.Leg.Foot</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-sec/java/foot">
<p>
L'enregistrement <code>Foot</code>, public et imbriqué dans l'interface <code>Leg</code>, représente une étape effectuée à pied. Il implémente donc <code>Leg</code> et possède les attributs suivants :
</p>
<dl class="org-dl">
<dt><code>Stop depStop</code></dt><dd>l'arrêt de départ de l'étape,</dd>
<dt><code>LocalDateTime depTime</code></dt><dd>la date/heure de départ de l'étape,</dd>
<dt><code>Stop arrStop</code></dt><dd>l'arrêt d'arrivée de l'étape,</dd>
<dt><code>LocalDateTime arrTime</code></dt><dd>la date/heure d'arrivée de l'étape.</dd>
</dl>
<p>
Le constructeur compact de <code>Foot</code> fait les mêmes vérifications que celui de <code>Transport</code>. En plus de ce constructeur compact, <code>Foot</code> possède deux méthodes publiques :
</p>
<dl class="org-dl">
<dt><code>List&lt;IntermediateStop&gt; intermediateStops()</code></dt><dd>qui implémente la méthode abstraite correspondante de l'interface <code>Leg</code> et retourne une liste vide, car une étape à pied ne comporte jamais d'arrêts intermédiaires,</dd>
<dt><code>boolean isTransfer()</code></dt><dd>qui retourne vrai ssi l'étape est un changement au sein de la même gare, c.-à-d. si le <i>nom</i> (!) de l'arrêt de départ est identique à celui de l'arrêt d'arrivée.</dd>
</dl>
<p>
Soyez attentifs au fait qu'une étape à pied entre deux arrêts différents peut être considérée comme un changement si ces arrêts ont le même nom. Par exemple, une étape entre la voie 70 et la voie 1 de la gare de Lausanne est un changement, même si les arrêts sont différents. Seul le fait que le nom de (la gare de) ces deux arrêts soit identique compte.
</p>
</div>
            </div>
        </div>
    
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/s scellées en Java.html">s scellées en Java</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-sec/sealed-interface">
<p>
En Java, une interface peut normalement être implémentée par n'importe quelle classe. Par exemple, l'interface <code>Leg</code> déclarée ci-dessus pourrait très bien être implémentée par d'autres classes que celles déclarées à l'intérieur de <code>Leg</code> (<code>Transport</code> et <code>Foot</code>).
</p>
<p>
Dans ce cas particulier, cela n'est toutefois pas souhaitable, car nous savons que les seuls types d'étapes qui existent dans le projet sont ces deux-là. Il serait donc bien de pouvoir communiquer cela à Java, afin d'interdire la définition d'autres classes implémentant l'interface <code>Leg</code>.
</p>
<p>
Cela peut se faire en <b>scellant</b> (<i>seal</i>) l'interface <code>Leg</code>, simplement en ajoutant le mot-clef <code>sealed</code> à l'interface, ainsi :
</p>
<div class="org-src-container">
<pre class="src src-java">public sealed interface Leg { … }
</pre>
</div>
<p>
Lorsqu'une interface est ainsi scellée, les seules classes qui ont le droit de l'implémenter sont celles se trouvant dans la même « unité de compilation », c.-à-d. le même fichier Java.
</p>
</div>
            </div>
        </div>
    
        <div class="class-card">
            <h3 class="card-title">
                <a href="classes/FormatterFr.html">FormatterFr</a>
            </h3>
            <div class="class-content">
                <div class="outline-text-3" id="text-3-13">
<p>
La classe <code>FormatterFr</code> du paquetage principal, publique, finale et non instanciable, contient des méthodes statiques permettant d'obtenir la représentation textuelle de différents types de données, au format décrit à la §<a href="#sec/text-repr">2.4</a>. Il s'agit de :
</p>
<dl class="org-dl">
<dt><code>String formatDuration(Duration duration)</code></dt><dd>qui retourne la représentation textuelle, décrite à la §<a href="#sec/repr/duration">2.4.1</a>, de la durée donnée,</dd>
<dt><code>String formatTime(LocalDateTime dateTime)</code></dt><dd>qui retourne la représentation textuelle, décrite à la §<a href="#sec/repr/time">2.4.2</a>, de l'heure de la date/heure donnée,</dd>
<dt><code>String formatPlatformName(Stop stop)</code></dt><dd>qui retourne la représentation textuelle, décrite à la §<a href="#sec/repr/platform">2.4.3</a>, de la voie ou quai de l'arrêt donné — ou une chaîne vide si l'arrêt en question est une gare, ou si son nom de voie/quai est vide,</dd>
<dt><code>String formatLeg(Journey.Leg.Foot footLeg)</code></dt><dd>qui retourne la représentation textuelle, décrite à la §<a href="#sec/repr/foot">2.4.4</a>, de l'étape à pied donnée,</dd>
<dt><code>String formatLeg(Journey.Leg.Transport leg)</code></dt><dd>qui retourne la représentation textuelle, décrite à la §<a href="#sec/repr/transport">2.4.5</a>, de l'étape en transport donnée,</dd>
<dt><code>String formatRouteDestination(Journey.Leg.Transport transportLeg)</code></dt><dd>qui retourne la représentation textuelle, décrite à la §<a href="#sec/repr/route">2.4.6</a>, de la ligne et du sens de parcours du véhicule emprunté pour effectuer l'étape donnée.</dd>
</dl>
</div>
            </div>
        </div>
    
                    </div>
                </div>
        
    </div>
</body>
</html>
