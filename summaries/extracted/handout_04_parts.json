{
  "intro": {
    "title": "Horaire aplati",
    "subtitle": "ReCHor – étape 4",
    "content": "<div class=\"outline-text-2\" id=\"text-1\">\n<p>\nLe but de cette étape est d'écrire des classes facilitant la lecture des données horaires aplaties, et de les utiliser pour écrire celles permettant de manipuler les gares et voies représentées de cette manière.\n</p>\n</div>"
  },
  "concepts": {
    "header": "2.1. Données aplaties",
    "subsections": [
      {
        "header": "2.1. Données aplaties",
        "content": "<div class=\"outline-text-3\" id=\"text-2-1\">\n<p>\nComme nous l'avons vu à l'étape précédente, les données horaire utilisées dans ce projet sont représentées d'une manière un peu particulière, que nous avons appelée <b>aplatie</b>.\n</p>\n<p>\nL'idée de cette représentation est que les différents types de données de l'horaire (gares, voies/quais, liaisons, etc.) sont stockés dans des tableaux, chaque tableau contenant toutes les valeurs d'un type donné, p. ex. toutes les gares. De plus, au lieu de contenir des références vers des objets contenant les attributs des différentes instances — comme d'habitude en Java — ces tableaux contiennent directement les attributs des différentes instances.\n</p>\n<p>\nÀ l'étape 3, pour simplifier les choses, nous avions fait l'hypothèse que les données représentées de manière aplatie étaient homogènes, dans le sens où tous leurs attributs pouvaient être représentés au moyen d'entiers du même type. Ainsi, dans l'exemple de la §2.1.3 de cette étape, les liaisons étaient composée de 4 attributs, et chacun d'entre eux pouvait être représenté au moyen d'un entier de type <code>short</code>. La totalité des liaisons pouvait donc être stockée dans un unique tableau de type <code>short[]</code>, de taille égale à 4 fois le nombre de liaisons.\n</p>\n<p>\nEn réalité, les données aplaties que nous utiliserons dans ce projet seront hétérogènes, dans le sens où elles seront constituées d'un certain nombre d'attributs ayant chacun un type potentiellement différent. Nous nommerons ces attributs des <b>champs</b> (<i>fields</i>), et ils pourront être chacun d'un des trois types entiers suivant :\n</p>\n<dl class=\"org-dl\">\n<dt><code>U8</code></dt><dd>8 bits (1 octet) interprétés comme un entier non signé, compris donc entre 0 (inclus) et 256 (exclu),</dd>\n<dt><code>U16</code></dt><dd>16 bits (2 octets) interprétés comme un entier non signé, compris donc entre 0 (inclus) et 65 536 (exclu),</dd>\n<dt><code>S32</code></dt><dd>32 bits (4 octets) interprétés comme un entier signé, compris donc entre<br/>\n–2 147 483 648 (inclus) et 2 147 483 648 (exclu).</dd>\n</dl>\n<p>\nCes trois types correspondent presque aux types <code>byte</code>, <code>short</code> et <code>int</code> de Java, la seule différence étant que les deux premiers sont interprétés de manière non signée.\n</p>\n<p>\nLes données hétérogènes sont stockées dans des tableaux d'octets (<i>bytes</i>), et un champ de type <code>U8</code> occupe donc un seul élément d'un tel tableau, un champ de type <code>U16</code> en occupe deux consécutifs, et un champ de type <code>S32</code> en occupe quatre consécutifs.\n</p>\n<p>\nComme les trois types de champs sont tous des types entiers, il faut trouver une manière de représenter <i>toutes</i> les données de l'horaire au moyen d'entiers, entre autres les nombreuses chaînes de caractères qu'elles contiennent.\n</p>\n</div>"
      },
      {
        "header": "2.2. Table des chaînes de caractères",
        "content": "<div class=\"outline-text-3\" id=\"text-2-2\">\n<p>\nDe nombreuses données de l'horaire contiennent des chaînes de caractères, p. ex. les gares ont un nom qui est une chaîne, et il en va de même pour les voies ou quais, les courses, etc.\n</p>\n<p>\nPour pouvoir représenter ces chaînes de caractères dans des données aplaties, une solution simple consiste à établir une table de toutes les chaînes présentes dans les données, puis d'identifier une chaîne par son index dans cette table.\n</p>\n<p>\nLes données horaires que nous utiliserons contiennent un peu plus de 40 000 chaînes différentes, et un index dans cette table peut donc être représenté par une valeur de type <code>U16</code>. Dans ce qui suit, nous nommerons ces index des <b>index de chaîne</b>.\n</p>\n</div>"
      },
      {
        "header": "2.3. Gares",
        "content": "<div class=\"outline-text-3\" id=\"text-sec/stations\">\n<p>\nLes gares sont représentées de manière aplatie au moyen des trois champs donnés dans la table ci-dessous, la colonne <code>I</code> donnant l'index du champ (à partir de 0) :\n</p>\n<table>\n<colgroup>\n<col class=\"org-right\"/>\n<col class=\"org-left\"/>\n<col class=\"org-left\"/>\n<col class=\"org-left\"/>\n</colgroup>\n<thead>\n<tr>\n<th class=\"org-right\" scope=\"col\"><code>I</code></th>\n<th class=\"org-left\" scope=\"col\">Champ</th>\n<th class=\"org-left\" scope=\"col\">Type</th>\n<th class=\"org-left\" scope=\"col\">Contenu</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td class=\"org-right\">0</td>\n<td class=\"org-left\"><code>NAME_ID</code></td>\n<td class=\"org-left\"><code>U16</code></td>\n<td class=\"org-left\">Index de chaîne du nom de la gare</td>\n</tr>\n<tr>\n<td class=\"org-right\">1</td>\n<td class=\"org-left\"><code>LON</code></td>\n<td class=\"org-left\"><code>S32</code></td>\n<td class=\"org-left\">Longitude de la gare</td>\n</tr>\n<tr>\n<td class=\"org-right\">2</td>\n<td class=\"org-left\"><code>LAT</code></td>\n<td class=\"org-left\"><code>S32</code></td>\n<td class=\"org-left\">Latitude de la gare</td>\n</tr>\n</tbody>\n</table>\n<p>\nLa représentation aplatie d'une gare nécessite donc 10 octets (sans compter ceux nécessaires à la représentation des chaînes dans la table des chaînes), et le tableau d'octets contenant la totalité des gares a donc une taille égale à 10 fois le nombre de gares.\n</p>\n<p>\nLa longitude et la latitude d'une gare aplatie ne sont <i>pas</i> exprimées en degrés, mais dans une unité anonyme, équivalente à \\(360°\\div 2^{32}\\). En d'autres termes, une longitude ou une latitude \\(l\\) exprimée dans cette unité anonyme peut être convertie en sa version en degrés \\(l°\\) au moyen de la formule suivante :\n</p>\n<p>\n\\[ l° = \\frac{360}{2^{32}}\\,l \\]\n</p>\n<p>\nL'intérêt de cette unité est qu'elle permet de représenter les longitudes et latitudes au moyen d'entiers de 32 bits, avec une précision de l'ordre du centimètre. En effet, sachant qu'à l'équateur la Terre a une circonférence d'environ 40 000 km, la précision est d'au moins :\n</p>\n<p>\n\\[ \\frac{40\\,000}{2^{32}}\\,\\textrm{km} \\approx 0.93\\,\\textrm{cm} \\]\n</p>\n<p>\nce qui suffit très largement à nos besoins.\n</p>\n</div>"
      },
      {
        "header": "2.4. Noms alternatifs des gares",
        "content": "<div class=\"outline-text-3\" id=\"text-sec/aliases\">\n<p>\nComme nous l'avons vu, certaines gares ont des noms alternatifs qui doivent pouvoir être utilisés dans la recherche d'arrêts, p. ex. <i>Losanna</i> pour <i>Lausanne</i>, <i>Soleure</i> pour <i>Solothurn</i>, <a href=\"https://fr.wikipedia.org/wiki/Anet_(Berne)\"><i>Anet</i></a> pour <a href=\"https://de.wikipedia.org/wiki/Ins_BE\"><i>Ins</i></a>, etc.\n</p>\n<p>\nCes noms alternatifs sont représentés comme des paires composées du nom alternatif et du nom original. La structure de cette table est donc très simple :\n</p>\n<table>\n<colgroup>\n<col class=\"org-right\"/>\n<col class=\"org-left\"/>\n<col class=\"org-left\"/>\n<col class=\"org-left\"/>\n</colgroup>\n<thead>\n<tr>\n<th class=\"org-right\" scope=\"col\"><code>I</code></th>\n<th class=\"org-left\" scope=\"col\">Champ</th>\n<th class=\"org-left\" scope=\"col\">Type</th>\n<th class=\"org-left\" scope=\"col\">Contenu</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td class=\"org-right\">0</td>\n<td class=\"org-left\"><code>ALIAS_ID</code></td>\n<td class=\"org-left\"><code>U16</code></td>\n<td class=\"org-left\">Index de chaîne du nom alternatif</td>\n</tr>\n<tr>\n<td class=\"org-right\">1</td>\n<td class=\"org-left\"><code>STATION_NAME_ID</code></td>\n<td class=\"org-left\"><code>U16</code></td>\n<td class=\"org-left\">Index de chaîne du nom de la gare</td>\n</tr>\n</tbody>\n</table>\n<p>\nLa représentation aplatie d'un nom alternatif d'une gare nécessite donc 4 octets.\n</p>\n</div>"
      },
      {
        "header": "2.5. Voies ou quais",
        "content": "<div class=\"outline-text-3\" id=\"text-sec/platforms\">\n<p>\nLes voies ou quai ont un nom (p. ex. <code>70</code>, <code>1AB</code>, <code>A</code>) et une référence vers la gare à laquelle ils appartiennent, que nous appellerons la <b>gare parente</b> (<i>parent station</i>).\n</p>\n<table>\n<colgroup>\n<col class=\"org-right\"/>\n<col class=\"org-left\"/>\n<col class=\"org-left\"/>\n<col class=\"org-left\"/>\n</colgroup>\n<thead>\n<tr>\n<th class=\"org-right\" scope=\"col\"><code>I</code></th>\n<th class=\"org-left\" scope=\"col\">Champ</th>\n<th class=\"org-left\" scope=\"col\">Type</th>\n<th class=\"org-left\" scope=\"col\">Contenu</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td class=\"org-right\">0</td>\n<td class=\"org-left\"><code>NAME_ID</code></td>\n<td class=\"org-left\"><code>U16</code></td>\n<td class=\"org-left\">Index de chaîne du nom de la voie ou du quai</td>\n</tr>\n<tr>\n<td class=\"org-right\">1</td>\n<td class=\"org-left\"><code>STATION_ID</code></td>\n<td class=\"org-left\"><code>U16</code></td>\n<td class=\"org-left\">Index de la gare parente</td>\n</tr>\n</tbody>\n</table>\n<p>\nLa représentation aplatie d'une voie ou d'un quai nécessite donc 4 octets.\n</p>\n<p>\nIl est important de comprendre que le premier champ (<code>NAME_ID</code>) contient un index dans la table des chaînes, mais le second (<code>STATION_ID</code>) contient un index dans la table des gares, et pas dans celle des chaînes !\n</p>\n</div>"
      },
      {
        "header": "2.6. Exemple",
        "content": "<div class=\"outline-text-3\" id=\"text-sec/example\">\n<p>\nPour illustrer la représentation aplatie des gares, de leurs noms alternatifs et des gares ou quais, admettons que la table des chaînes de caractères contienne les éléments suivants :\n</p>\n<table>\n<colgroup>\n<col class=\"org-right\"/>\n<col class=\"org-left\"/>\n</colgroup>\n<thead>\n<tr>\n<th class=\"org-right\" scope=\"col\"><code>I</code></th>\n<th class=\"org-left\" scope=\"col\">Chaîne</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td class=\"org-right\">0</td>\n<td class=\"org-left\"><code>1</code></td>\n</tr>\n<tr>\n<td class=\"org-right\">1</td>\n<td class=\"org-left\"><code>70</code></td>\n</tr>\n<tr>\n<td class=\"org-right\">2</td>\n<td class=\"org-left\"><code>Anet</code></td>\n</tr>\n<tr>\n<td class=\"org-right\">3</td>\n<td class=\"org-left\"><code>Ins</code></td>\n</tr>\n<tr>\n<td class=\"org-right\">4</td>\n<td class=\"org-left\"><code>Lausanne</code></td>\n</tr>\n<tr>\n<td class=\"org-right\">5</td>\n<td class=\"org-left\"><code>Losanna</code></td>\n</tr>\n<tr>\n<td class=\"org-right\">6</td>\n<td class=\"org-left\"><code>Palézieux</code></td>\n</tr>\n</tbody>\n</table>\n<p>\net voyons ensuite comment représenter des gares, noms alternatifs et voies/quai aplatis.\n</p>\n</div>"
      }
    ]
  },
  "implementation": {
    "header": "3.1. Classe Structure",
    "classes": [
      {
        "name": "Structure",
        "header": "3.1. Classe Structure",
        "content": "<div class=\"outline-text-3\" id=\"text-3-1\">\n<p>\nLa classe <code>Structure</code> du sous-paquetage <code>timetable.mapped</code> a pour but de faciliter la description de la structure des données aplaties. Ainsi, une fois terminée, cette classe permet d'écrire le code suivant pour décrire les noms alternatifs des gares :\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-java\">int ALIAS_ID = 0;\nint STATION_NAME_ID = 1;\n\nStructure STRUCTURE = new Structure(\n    field(ALIAS_ID, U16),\n    field(STATION_NAME_ID, U16));\n</pre>\n</div>\n<p>\nqui est très proche de la table donnée à la §<a href=\"#sec/aliases\">2.4</a>, les constantes <code>ALIAS_ID</code> et <code>STATION_NAME_ID</code> contenant les index (colonne <code>I</code>) des différents champs.\n</p>\n<p>\nUne fois cette définition écrite, il est par exemple possible de calculer l'index, dans le tableau d'octets contenant les données aplaties, du premier octet de l'index de chaîne du nom de gare du second nom alternatif d'une table (celui d'index 1), ainsi :\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-java\">int offset = STRUCTURE.offset(STATION_NAME_ID, 1);\n</pre>\n</div>\n<p>\nqui vaut 6.\n</p>\n<p>\n<code>Structure</code> possède un type énuméré imbriqué public nommé <code>FieldType</code> représentant les trois types de champs possibles, à savoir <code>U8</code>, <code>U16</code> et <code>S32</code>.\n</p>\n<p>\nDe plus, elle possède un enregistrement imbriqué public nommé <code>Field</code>, qui représente un champ et possède les deux attributs suivants, dans l'ordre :\n</p>\n<dl class=\"org-dl\">\n<dt><code>int index</code></dt><dd>l'index du champ dans la structure (colonne <code>I</code> dans les tables plus haut),</dd>\n<dt><code>FieldType type</code></dt><dd>le type du champ.</dd>\n</dl>\n<p>\n<code>Field</code> possède un constructeur compact qui lève une <code>NullPointerException</code> ssi <code>type</code> est <code>null</code>.\n</p>\n<p>\n<code>Structure</code> possède de plus une méthode publique et statique dont le but est d'alléger un peu la création d'instances de <code>Field</code>, en omettant le <code>new</code>, comme dans l'exemple plus haut :\n</p>\n<dl class=\"org-dl\">\n<dt><code>Field field(int index, FieldType type)</code></dt><dd>qui retourne une instance de <code>Field</code> avec les attributs donnés.</dd>\n</dl>\n<p>\n<code>Structure</code> possède un unique constructeur, qui prend en arguments la description des différents champs de la structure :\n</p>\n<dl class=\"org-dl\">\n<dt><code>Structure(Field... fields)</code></dt><dd>qui retourne une structure dont les champs sont ceux donnés, ou lève une <code>IllegalArgumentException</code> si ces champs ne sont pas donnés dans l'ordre — c.-à-d. si le premier d'entre eux n'est pas celui d'index 0, le second celui d'index 1, etc.</dd>\n<dt><code>int totalSize()</code></dt><dd>qui retourne la taille totale, en octets, de la structure — p. ex. 10 pour celle correspondant aux gares,</dd>\n<dt><code>int offset(int fieldIndex, int elementIndex)</code></dt><dd>qui retourne l'index, dans le tableau d'octets contenant les données aplaties, du premier octet du champ d'index <code>fieldIndex</code> de l'élément d'index <code>elementIndex</code> ; lève <code>IndexOutOfBoundsException</code> si l'index du champ est invalide.</dd>\n</dl>\n</div>"
      },
      {
        "name": "StructuredBuffer",
        "header": "3.2. Classe StructuredBuffer",
        "content": "<div class=\"outline-text-3\" id=\"text-3-2\">\n<p>\nLa classe <code>StructuredBuffer</code> du sous-paquetage <code>timetable.mapped</code>, représente un « tableau d'octets structuré ». Son but est d'offrir un accès agréable à des données aplaties stockées dans un tableau d'octets, et dont la structure est décrite par une instance de <code>Structure</code>.\n</p>\n<p>\nUne fois cette classe terminée, il sera possible de l'utiliser par exemple ainsi pour obtenir l'index de chaîne du nom alternatif d'index 1 :\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-java\">StructuredBuffer buffer = …;\nint stationNameStringIndex = buffer.getU16(STATION_NAME_ID, 1);\n</pre>\n</div>\n<p>\nDans l'exemple de la §<a href=\"#sec/example\">2.6</a>, <code>stationNameStringIndex</code> vaudrait 3, car c'est l'index de chaîne <i>Ins</i>.\n</p>\n<p>\n<code>StructuredBuffer</code> possède un unique constructeur public :\n</p>\n<dl class=\"org-dl\">\n<dt><code>StructuredBuffer(Structure structure, ByteBuffer buffer)</code></dt><dd>qui construit un tableau structuré dont les éléments ont la structure donnée, et dont les octets sont stockés dans le « tableau » <code>buffer</code>, ou lève une <code>IllegalArgumentException</code> si le nombre d'octets de ce tableau n'est pas un multiple de la taille totale de la structure.</dd>\n</dl>\n<p>\nLa classe <code>ByteBuffer</code>, qui appartient à la bibliothèque Java, est décrite dans les conseils de programmation ci-dessous.\n</p>\n<p>\nEn plus de son constructeur, <code>StructuredBuffer</code> offre les méthodes publiques suivantes :\n</p>\n<dl class=\"org-dl\">\n<dt><code>int size()</code></dt><dd>qui retourne le nombre d'éléments que contient le tableau, p. ex. 3 pour les voies/quais de la §<a href=\"#sec/example\">2.6</a>,</dd>\n<dt><code>int getU8(int fieldIndex, int elementIndex)</code></dt><dd>qui retourne l'entier <code>U8</code> correspondant au champ d'index <code>fieldIndex</code> de l'élément d'index <code>elementIndex</code> du tableau, ou lève <code>IndexOutOfBoundsException</code> si l'un des deux index est invalide,</dd>\n<dt><code>int getU16(int fieldIndex, int elementIndex)</code></dt><dd>qui fait la même chose que <code>getU8</code> mais pour un champ de type <code>U16</code>,</dd>\n<dt><code>int getS32(int fieldIndex, int elementIndex)</code></dt><dd>qui fait la même chose que <code>getU8</code> mais pour un champ de type <code>S32</code>.</dd>\n</dl>\n<p>\nN'oubliez pas que les valeurs retournées par <code>getU8</code> et <code>getU16</code> doivent être positives, car les champs de ces deux types sont interprétés de manière non signée. C'est la raison pour laquelle ces méthodes retournent une valeur de type <code>int</code> et pas <code>byte</code> ou <code>short</code>.\n</p>\n</div>"
      },
      {
        "name": "BufferedStations",
        "header": "3.3. Classe BufferedStations",
        "content": "<div class=\"outline-text-3\" id=\"text-3-3\">\n<p>\nLa classe <code>BufferedStations</code> du sous-paquetage <code>timetable.mapped</code>, publique et finale, implémente l'interface <code>Stations</code> et permet d'accéder à une table de gares représentée de manière aplatie comme décrit à la §<a href=\"#sec/stations\">2.3</a>. Elle possède un unique constructeur public :\n</p>\n<dl class=\"org-dl\">\n<dt><code>BufferedStations(List&lt;String&gt; stringTable, ByteBuffer buffer)</code></dt><dd>qui construit une instance donnant accès aux données aplaties disponibles dans le tableau <code>buffer</code>, en utilisant la table de chaînes <code>stringTable</code> pour déterminer la valeur des chaînes référencées par ces données.</dd>\n</dl>\n<p>\nLes seules méthodes publiques offertes par cette classe sont les versions concrètes des méthodes abstraites de <code>Stations</code>.\n</p>\n</div>"
      },
      {
        "name": "BufferedStationAliases",
        "header": "3.4. Classe BufferedStationAliases",
        "content": "<div class=\"outline-text-3\" id=\"text-3-4\">\n<p>\nLa classe <code>BufferedStationAliasess</code> du sous-paquetage <code>timetable.mapped</code>, publique et finale, implémente l'interface <code>StationAliases</code> et permet d'accéder à une table de noms alternatifs de gares représentée de manière aplatie comme décrit à la §<a href=\"#sec/aliases\">2.4</a>. Elle possède un unique constructeur public :\n</p>\n<dl class=\"org-dl\">\n<dt><code>BufferedStationAliases(List&lt;String&gt; stringTable, ByteBuffer buffer)</code></dt><dd>qui construit une instance donnant accès aux données aplaties disponibles dans le tableau <code>buffer</code>, en utilisant la table de chaînes <code>stringTable</code> pour déterminer la valeur des chaînes référencées par ces données.</dd>\n</dl>\n<p>\nLes seules méthodes publiques offertes par cette classe sont les versions concrètes des méthodes abstraites de <code>StationAliases</code>.\n</p>\n</div>"
      },
      {
        "name": "BufferedPlatforms",
        "header": "3.5. Classe BufferedPlatforms",
        "content": "<div class=\"outline-text-3\" id=\"text-3-5\">\n<p>\nLa classe <code>BufferedPlatforms</code> du sous-paquetage <code>timetable.mapped</code>, publique et finale, implémente l'interface <code>Platforms</code> et permet d'accéder à une table de voies ou quais représentée de manière aplatie comme décrit à la §<a href=\"#sec/platforms\">2.5</a>. Elle possède un unique constructeur public :\n</p>\n<dl class=\"org-dl\">\n<dt><code>BufferedPlatforms(List&lt;String&gt; stringTable, ByteBuffer buffer)</code></dt><dd>qui construit une instance donnant accès aux données aplaties disponibles dans le tableau <code>buffer</code>, en utilisant la table de chaînes <code>stringTable</code> pour déterminer la valeur des chaînes référencées par ces données.</dd>\n</dl>\n<p>\nLes seules méthodes publiques offertes par cette classe sont les versions concrètes des méthodes abstraites de <code>Platforms</code>.\n</p>\n</div>"
      }
    ],
    "other_subsections": [
      {
        "header": "3.6. Tests",
        "content": "<div class=\"outline-text-3\" id=\"text-3-6\">\n<p>\nComme d'habitude, nous ne vous fournissons plus de tests mais <a href=\"f/SignatureChecks_4.java\">un fichier de vérification de signatures</a> à importer dans votre projet.\n</p>\n<p>\nPour écrire vos tests, vous pouvez entre autres vous aider des valeurs d'exemple données à la §<a href=\"#sec/example\">2.6</a>. Grâce à la classe <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/HexFormat.html\"><code>HexFormat</code></a> de la bibliothèque Java, il est très simple d'obtenir le tableau d'octets correspondant à une chaîne ayant le même format que celui de cette section. Par exemple, pour obtenir le tableau d'octets des noms alternatifs, on peut procéder ainsi :\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-java\">HexFormat hexFormat = HexFormat.ofDelimiter(\" \");\nbyte[] bytes = hexFormat.parseHex(\"00 05 00 04 00 02 00 03\");\n</pre>\n</div>\n<p>\nUne fois ce tableau obtenu, la méthode <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/nio/ByteBuffer.html#wrap(byte%5B%5D)\"><code>wrap</code></a> de <code>ByteBuffer</code> permet d'obtenir une valeur de type <code>ByteBuffer</code> qui peut directement être passée au constructeur de <code>BufferedStationAliases</code>.\n</p>\n</div>"
      }
    ]
  }
}