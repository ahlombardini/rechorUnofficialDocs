{
  "intro": {
    "title": "Mise en place",
    "subtitle": "ReCHor – étape 1",
    "content": "<div class=\"outline-text-2\" id=\"text-1\">\n<p>\nLe but de cette première étape est d'écrire des classes et interfaces représentant quelques concepts importants du projet — les arrêts de transport public, les voyages (relations), etc. — ainsi que le code permettant de les représenter sous forme textuelle.\n</p>\n<p>\nComme toutes les descriptions d'étapes, celle-ci commence par une introduction aux concepts nécessaires à sa réalisation (§<a href=\"#sec/concepts\">2</a>), suivie d'une présentation de leur mise en œuvre en Java (§<a href=\"#sec/implementation\">3</a>).\n</p>\n<p>\nSi vous travaillez en groupe, vous êtes toutefois priés de lire, avant de continuer, les guides <a href=\"../g/group-work.html\"><i>Travailler en groupe</i></a> et <a href=\"../g/sync.html\"><i>Synchroniser son travail</i></a>, qui vous aideront à bien vous organiser.\n</p>\n</div>"
  },
  "concepts": {
    "header": "2.1. Arrêt",
    "subsections": [
      {
        "header": "2.1. Arrêt",
        "content": "<div class=\"outline-text-3\" id=\"text-2-1\">\n<p>\nUn <b>arrêt</b> (<i>stop</i> en anglais) est un endroit où un véhicule de transport public peut s'arrêter afin de laisser monter et/ou descendre des passagers. Dans ce projet, nous en distinguerons deux types :\n</p>\n<ol class=\"org-ol\">\n<li>les <b>gares</b> (<i>stations</i>), qui correspondent soit à ce que l'on entend effectivement par « gare » dans le langage courant, comme la gare de Lausanne, soit à des arrêts assez petits pour que la distinction entre les différentes voies/quais ne soit pas jugée nécessaire,</li>\n<li>les <b>voies</b> ou <b>quais</b> (<i>platforms</i>), qui correspondent aux différentes voies ou quais d'une gare ferroviaire ou routière.</li>\n</ol>\n<p>\nLes arrêts possèdent un nom (p.ex. <i>Lausanne</i>) et une position géographique, donnée par un couple longitude/latitude (p.ex. <a href=\"https://www.openstreetmap.org/?mlat=46.516789&amp;mlon=6.629092#map=19/46.516789/6.629092\">6.62909°, 46.51679°</a>). Les voies ou quais possèdent de plus un nom de voie (ou de quai). En Suisse, ce nom est généralement — mais pas toujours — un nombre pour les voies ferroviaires, éventuellement accompagné d'une désignation de secteur (1, 3BC, etc.) et une lettre pour les quais de gare routière (A, B, etc.).\n</p>\n<p>\nIl n'est pas forcément évident de décider ce qui constitue un arrêt, et des choix qui peuvent sembler surprenants ont parfois été faits en Suisse.\n</p>\n<p>\nPar exemple, dans les données d'horaires officielles que nous utiliserons, l'arrêt du métro m1 à l'EPFL est représenté par un unique arrêt — une gare —, malgré le fait qu'il y ait deux voies.\n</p>\n<p>\nÀ l'inverse, de nombreux arrêts existent pour la gare de Lausanne. Non seulement l'arrêt nommé <i>Lausanne</i>, qui correspond à la gare elle-même, ainsi que des arrêts correspondants aux différentes voies ferroviaires (1, 3 à 8 et 70), mais aussi l'arrêt de bus nommé <i>Lausanne, gare</i>, qui n'est représenté que par un seul arrêt alors que les différents bus s'arrêtent à plusieurs endroits assez distants les uns des autres.\n</p>\n</div>"
      },
      {
        "header": "2.2. Ligne",
        "content": "<div class=\"outline-text-3\" id=\"text-2-2\">\n<p>\nUn véhicule de transport public se déplace toujours en suivant une <b>ligne</b> (<i>route</i>), p. ex. la ligne de métro m1, ou alors <a href=\"https://network.sbb.ch/fr/ligne/IR15\">la ligne IR 15 des CFF</a> qui relie <i>Genève-Aéroport</i> à <i>Lucerne</i> en desservant une dizaine d'arrêts intermédiaires entre les deux.\n</p>\n<p>\nLe sens dans lequel un véhicule se déplace sur une ligne est généralement indiqué par sa destination finale — <i>Genève-Aéroport</i> ou <i>Lucerne</i> dans le cas de la ligne IR 15.\n</p>\n</div>"
      },
      {
        "header": "2.3. Voyage",
        "content": "<div class=\"outline-text-3\" id=\"text-sec/journey\">\n<p>\nNous nommerons <b>voyage</b> (<i>journey</i>) un déplacement entre deux arrêts de transports publics. Un voyage est ce que nous avons appelé une relation dans <a href=\"00.html\">l'introduction au projet</a>, terme que nous n'utiliserons plus par la suite.\n</p>\n<p>\nUn voyage est constitué d'une ou plusieurs <b>étapes</b> (<i>legs</i>), chacune d'entre elles partant d'un arrêt de départ à un instant donné et arrivant à un arrêt d'arrivée à un instant ultérieur. Il existe deux types différents d'étapes :\n</p>\n<ol class=\"org-ol\">\n<li>celles effectuées à pied, soit entre deux arrêts voisins ou alors au sein d'un même arrêt lors d'un changement,</li>\n<li>celles effectuées en transport public — train, bus, métro, etc.</li>\n</ol>\n<p>\nLes étapes effectuées en transport public peuvent éventuellement comporter des arrêts intermédiaires entre l'arrêt de départ de l'étape et celui d'arrivée. De plus, elles sont toujours effectuées à bord d'un unique véhicule qui suit une ligne donnée, dans une direction donnée.\n</p>\n<p>\nUn voyage est valide si et seulement si ses étapes satisfont les conditions suivantes :\n</p>\n<ol class=\"org-ol\">\n<li>l'instant de départ d'une étape ne précède pas l'instant d'arrivée de l'étape précédente, s'il y en a une,</li>\n<li>l'arrêt de départ d'une étape est identique à l'arrêt d'arrivée de l'étape précédente, s'il y en a une,</li>\n<li>les étapes à pied alternent avec les étapes en transport public.</li>\n</ol>\n<p>\nUn exemple de voyage valide pourrait être celui présenté dans l'introduction au projet qui va de l'arrêt <i>Ecublens VD, EPFL</i> (départ à 16h13 le 18 février 2025) à l'arrêt <i>Gruyères</i> (arrivée à 17h57). Il est constitué de neuf étapes, les cinq premières étant :\n</p>\n<ol class=\"org-ol\">\n<li>de <i>Ecublens VD, EPFL</i> (dép. à 16h13) à <i>Renens VD, gare</i> (arr. à 16h19), avec le métro de la ligne m1 en direction de <i>Renens VD, gare</i>,</li>\n<li>de <i>Renens VD, gare</i> (dép. à 16h19) à <i>Renens VD</i>, voie 4 (arr. à 16h22), à pied (trajet entre deux arrêts voisins),</li>\n<li>de <i>Renens VD</i>, voie 4 (dép. à 16h26) à <i>Lausanne</i>, voie 5 (arr. à 16h33) avec le train de la ligne R 4 en direction de <i>Bex</i>,</li>\n<li>de <i>Lausanne</i>, voie 5 (dép. à 16h33) à <i>Lausanne</i>, voie 1 (arr. à 16h38), à pied (changement au sein de la même gare),</li>\n<li>de <i>Lausanne</i>, voie 1 (dép. à 16h40) à <i>Romont FR</i>, voie 2 (arr. à 17h13) avec le train de la ligne IR 15 en direction de <i>Luzern</i> (Lucerne).</li>\n</ol>\n<p>\nIl va sans dire que les voyages jouent un rôle central dans ce projet, dont le but principal est de calculer l'ensemble des voyages permettant de relier de manière optimale deux arrêts, à une date et une heure donnée.\n</p>\n</div>"
      },
      {
        "header": "2.4. Représentation textuelle",
        "content": "<div class=\"outline-text-3\" id=\"text-sec/text-repr\">\n<p>\nPlusieurs des concepts décrits ci-dessus, par exemple les étapes d'un voyage, doivent pouvoir être représentés sous forme de texte afin d'être affichés à l'écran ou alors inclus dans un événement de calendrier. Les sections qui suivent décrivent la manière dont nous représenterons textuellement ces concepts — et d'autres — dans ce projet.\n</p>\n</div>"
      }
    ]
  },
  "implementation": {
    "header": "3.1. Installation de Java et d'IntelliJ",
    "classes": [
      {
        "name": "Preconditions",
        "header": "3.3. Classe Preconditions",
        "content": "<div class=\"outline-text-3\" id=\"text-3-3\">\n<p>\nFréquemment, les méthodes d'un programme exigent que leurs arguments satisfassent certaines conditions. Par exemple, une méthode déterminant la valeur maximale d'un tableau d'entiers exige que ce tableau contienne au moins un élément.\n</p>\n<p>\nDe telles conditions sont souvent appelées <b>préconditions</b> (<i>preconditions</i>) car elles doivent être satisfaites <i>avant</i> l'appel d'une méthode : c'est à l'appelant de s'assurer qu'il n'appelle la méthode qu'avec des arguments valides.\n</p>\n<p>\nEn Java, la convention veut que chaque méthode vérifie, autant que possible, ses préconditions et lève une exception — souvent <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/IllegalArgumentException.html\"><code>IllegalArgumentException</code></a> — si l'une d'entre elles n'est pas satisfaite. Par exemple, une méthode <code>max</code> calculant la valeur maximale d'un tableau d'entiers, et exigeant logiquement que celui-ci contienne au moins un élément, pourrait commencer ainsi :\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-java\">int max(int[] array) {\n  if (! (array.length &gt; 0))\n    throw new IllegalArgumentException();\n  // … reste du code\n}\n</pre>\n</div>\n<p>\n(Notez au passage que la méthode <code>max</code> ne déclare <i>pas</i> qu'elle lève potentiellement <code>IllegalArgumentException</code> au moyen d'une clause <code>throws</code>, car cette exception est de type <i>unchecked</i>.)\n</p>\n<p>\nLa première classe à réaliser dans le cadre de ce projet a pour but de faciliter l'écriture de telles préconditions. En l'utilisant, la méthode ci-dessus pourrait être simplifiée ainsi :\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-java\">int max(int[] array) {\n  Preconditions.checkArgument(array.length &gt; 0);\n  // … reste du code\n}\n</pre>\n</div>\n<p>\nCette classe est nommée <code>Preconditions</code> et appartient au paquetage principal. Elle est publique et finale et n'offre rien d'autre que la méthode <code>checkArgument</code> décrite plus bas. Elle a toutefois la particularité d'avoir un constructeur par défaut privé :\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-java\">public final class Preconditions {\n  private Preconditions() {}\n  // … méthode(s)\n}\n</pre>\n</div>\n<p>\nLe but de ce constructeur privé est de rendre impossible la création d'instances de la classe, puisque cela n'a clairement aucun sens — elle ne sert que de conteneur à une méthode statique. Dans la suite du projet, nous définirons plusieurs autres classes du même type, que nous appellerons dès maintenant classes <b>non instanciables</b>.\n</p>\n<p>\nLa méthode publique (et statique) offerte par la classe <code>Preconditions</code> est :\n</p>\n<dl class=\"org-dl\">\n<dt><code>void checkArgument(boolean shouldBeTrue)</code></dt><dd>qui lève l'exception <code>IllegalArgumentException</code> si son argument est faux, et ne fait rien sinon.</dd>\n</dl>\n</div>"
      },
      {
        "name": "s Java",
        "header": "3.5. Enregistrements Java",
        "content": "<div class=\"outline-text-3\" id=\"text-3-5\">\n<p>\nAvant de décrire <code>Stop</code>, la prochaine classe à mettre en œuvre pour cette étape, il convient de décrire le concept de <b>classe enregistrement</b> (<i>record class</i>), ou simplement <b>enregistrement</b> (<i>record</i>), introduit dans la version 17 de Java.\n</p>\n<p>\nUn enregistrement est un type particulier de classe qui peut se définir au moyen d'une syntaxe plus concise qu'une classe normale. Dans cette syntaxe, le mot-clef <code>class</code> est remplacé par <code>record</code> et les attributs de la classe sont donnés entre parenthèses, après son nom.\n</p>\n<p>\nPar exemple, un enregistrement nommé <code>Complex</code> représentant un nombre complexe dont les attributs sont sa partie réelle <code>re</code> et sa partie imaginaire <code>im</code> — tous deux de type <code>double</code> — peut se définir ainsi :\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-java\">public record Complex(double re, double im) { }\n</pre>\n</div>\n<p>\nCette définition est équivalente à celle d'une classe finale (!) dotée de :\n</p>\n<ul class=\"org-ul\">\n<li>deux attributs privés et finaux nommés <code>re</code> et <code>im</code> de type <code>double</code>,</li>\n<li>un constructeur prenant en argument la valeur de ces attributs et les initialisant,</li>\n<li>des méthodes d'accès (<i>getters</i>) publics nommés <code>re()</code> et <code>im()</code> pour ces attributs,</li>\n<li>une méthode <code>equals</code> retournant vrai si et seulement si l'objet qu'on lui passe est aussi une instance de <code>Complex</code> et que ses attributs sont égaux à ceux de <code>this</code>,</li>\n<li>une méthode <code>hashCode</code> compatible avec la méthode <code>equals</code> — le but de cette méthode et la signification de sa compatibilité avec <code>equals</code> seront examinés ultérieurement dans le cours,</li>\n<li>une méthode <code>toString</code> retournant une chaîne composée du nom de la classe et du nom et de la valeur des attributs de l'instance, p. ex. <code>Complex[re=1.0, im=2.0]</code>.</li>\n</ul>\n<p>\nEn d'autres termes, la définition plus haut, qui tient sur une ligne, est équivalente à la définition suivante, qui n'utilise que des concepts que vous connaissez déjà :\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-java\">public final class Complex {\n  private final double re;\n  private final double im;\n\n  public Complex(double re, double im) {\n    this.re = re;\n    this.im = im;\n  }\n\n  public double re() { return re; }\n  public double im() { return im; }\n\n  @Override\n  public boolean equals(Object that) {\n    // … vrai ssi that :\n    // 1. est aussi une instance de Complex, et\n    // 2. ses attributs re et im sont identiques.\n  }\n\n  @Override\n  public int hashCode() {\n    // … code omis car peu important\n  }\n\n  @Override\n  public String toString() {\n    return \"Complex[re=\" + re + \", im=\" + im + \"]\";\n  }\n}\n</pre>\n</div>\n<p>\nComme cet exemple l'illustre, les enregistrements permettent d'éviter d'écrire beaucoup de code répétitif, ce que les anglophones appellent du <a href=\"https://en.wikipedia.org/wiki/Boilerplate_code\"><i>boilerplate code</i></a>. Il faut toutefois bien comprendre qu'en dehors d'une syntaxe très concise, les enregistrements n'apportent — pour l'instant en tout cas — rien de nouveau à Java, dans le sens où il est toujours possible de récrire un enregistrement en une classe Java équivalente, comme ci-dessus. En cela, les enregistrements sont similaires aux types énumérés.\n</p>\n<p>\nIl est bien entendu possible de définir des méthodes dans un enregistrement, qui viennent s'ajouter à celles définies automatiquement. Par exemple, pour doter l'enregistrement <code>Complex</code> d'une méthode <code>modulus</code> retournant son module, il suffit de l'ajouter entre les accolades, ainsi :\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-java\">public record Complex(double re, double im) {\n  public double modulus() { return Math.hypot(re, im); }\n}\n</pre>\n</div>\n<p>\n(La méthode <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Math.html#hypot(double,double)\"><code>Math.hypot(x,y)</code></a> retourne \\(\\sqrt{x^2 + y^2}\\)).\n</p>\n<p>\nFinalement, il est aussi possible de définir ce que l'on nomme un <b>constructeur compact</b> (<i>compact constructor</i>), qui augmente le constructeur que Java ajoute par défaut aux enregistrements. Un constructeur compact doit son nom au fait qu'il semble ne prendre aucun argument, et n'initialise pas explicitement les attributs. En réalité, il prend des arguments qui sont les mêmes que ceux de l'enregistrement (<code>re</code> et <code>im</code> dans notre exemple), et Java lui ajoute automatiquement des affectations de ces arguments aux attributs correspondants.\n</p>\n<p>\nPar exemple, on pourrait vouloir ajouter un constructeur compact à la classe <code>Complex</code> pour lever une exception si l'un des arguments passés au constructeur était une valeur <code>NaN</code> (<i>not a number</i>, une valeur invalide). On pourrait le faire ainsi :\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-java\">public record Complex(double re, double im) {\n  public Complex {  // constructeur compact\n    if (Double.isNaN(re) || Double.isNaN(im))\n      throw new IllegalArgumentException();\n  }\n  // … méthode modulus\n}\n</pre>\n</div>\n<p>\nCe constructeur compact serait automatiquement traduit en :\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-java\">public final class Complex {\n  // … attributs re et im\n\n  public Complex(double re, double im) {\n    if (Double.isNaN(re) || Double.isNaN(im))\n      throw new IllegalArgumentException();\n    this.re = re;  // ajouté automatiquement\n    this.im = im;  // ajouté automatiquement\n  }\n\n  // … méthodes modulus, re, im, hashCode, etc.\n}\n</pre>\n</div>\n<p>\nLes enregistrements ne seront pas décrits en détail dans le cours, mais seront introduits au moyen d'exemples similaires à ceux ci-dessus dans la suite du projet. Les personnes intéressées par les détails de leur fonctionnement pourront se rapporter à la <a href=\"https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.10\">§8.10 (<i>Record Classes</i>) de la spécification du langage</a>.\n</p>\n</div>"
      },
      {
        "name": "Stop",
        "header": "3.6. Enregistrement Stop",
        "content": "<div class=\"outline-text-3\" id=\"text-3-6\">\n<p>\nL'enregistrement <code>Stop</code> du sous-paquetage <code>journey</code>, public, représente un\narrêt de transport public. Cet enregistrement est utilisé à la fois pour les gares et pour les voies ou quais. Il possède les attributs suivants :\n</p>\n<dl class=\"org-dl\">\n<dt><code>String name</code></dt><dd>le nom de l'arrêt, ou le nom de la gare à laquelle appartient l'arrêt s'il représente une voie ou un quai,</dd>\n<dt><code>String platformName</code></dt><dd>le nom de la voie ou du quai de l'arrêt, ou <code>null</code> si l'arrêt correspond à une gare,</dd>\n<dt><code>double longitude</code></dt><dd>la longitude de la position de l'arrêt, en degrés,</dd>\n<dt><code>double latitude</code></dt><dd>la latitude de la position de l'arrêt, en degrés.</dd>\n</dl>\n<p>\nPar exemple, l'arrêt correspondant à la gare de Lausanne pourrait être construit ainsi :\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-java\">Stop l = new Stop(\"Lausanne\", null, 6.62909, 46.51679);\n</pre>\n</div>\n<p>\ntandis que celui correspondant à la voie 70 de cette même gare pourrait l'être ainsi :\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-java\">Stop l70 = new Stop(\"Lausanne\", \"70\", 6.62909, 46.51679);\n</pre>\n</div>\n<p>\n<code>Stop</code> possède un constructeur compact chargé de valider les arguments et qui :\n</p>\n<ul class=\"org-ul\">\n<li>lève une <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/NullPointerException.html\"><code>NullPointerException</code></a> si <code>name</code> est <code>null</code>, ou</li>\n<li>lève une <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/IllegalArgumentException.html\"><code>IllegalArgumentException</code></a> si <code>longitude</code> n'est pas compris entre ±180° (inclus) ou si <code>latitude</code> n'est pas compris entre ±90° (inclus).</li>\n</ul>\n<p>\n<code>Stop</code> ne possède aucune autre méthode que celles ajoutées automatiquement aux enregistrements par Java.\n</p>\n</div>"
      },
      {
        "name": "Journey",
        "header": "3.7. Enregistrement Journey",
        "content": "<div class=\"outline-text-3\" id=\"text-3-7\">\n<p>\nL'enregistrement <code>Journey</code>, du sous-paquetage <code>journey</code>, public et immuable, représente un voyage. Il possède un unique attribut :\n</p>\n<dl class=\"org-dl\">\n<dt><code>List&lt;Leg&gt; legs</code></dt><dd>les étapes du voyage.</dd>\n</dl>\n<p>\nLe type <code>Leg</code> est celui d'une interface imbriquée à l'intérieur de l'enregistrement <code>Journey</code> et décrite à la §<a href=\"#sec/java/leg\">3.8</a>. Comme expliqué dans cette section et celles qui suivent, trois enregistrements (<code>IntermediateStop</code>, <code>Transport</code> et <code>Foot</code>) sont imbriqués dans <code>Leg</code>. Cela signifie que <code>Journey</code> a la structure suivante :\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-java\">public record Journey(/* … attributs */) {\n  public interface Leg {\n    public record IntermediateStop(/* … attributs */) {\n      /* … constructeur et/ou méthodes */\n    }\n    /* … autres enregistrements imbriqués, méthodes */\n  }\n  /* … constructeur et/ou méthodes */\n}\n</pre>\n</div>\n<p>\nEn raison de cette imbrication, la notation pointée doit être utilisée depuis l'extérieur pour accéder à l'interface <code>Leg</code> et aux enregistrements <code>IntermediateStop</code>, <code>Transport</code> et <code>Foot</code>. Par exemple, pour créer une instance de l'enregistrement <code>IntermediateStop</code>, on écrira :\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-java\">new Journey.Leg.IntermediateStop(/* … arguments */);\n</pre>\n</div>\n<p>\n<code>Journey</code> possède un constructeur compact qui valide la liste des étapes reçue  en vérifiant que :\n</p>\n<ul class=\"org-ul\">\n<li>elle n'est pas vide,</li>\n<li>les étapes à pied alternent avec celles en transport,</li>\n<li>pour toutes les étapes sauf la première, l'instant de départ ne précède pas celui d'arrivée de la précédente,</li>\n<li>pour toutes les étapes sauf la première, l'arrêt de départ est identique à l'arrêt d'arrivée de la précédente.</li>\n</ul>\n<p>\nSi l'une de ces conditions n'est pas satisfaite, le constructeur compact lève une <code>IllegalArgumentException</code>. Sinon, dans le but de garantir l'immuabilité de la classe, il copie la liste des étapes en utilisant la technique décrite dans les conseils de programmation plus bas.\n</p>\n<p>\n<code>Journey</code> offre les méthodes publiques suivantes :\n</p>\n<dl class=\"org-dl\">\n<dt><code>Stop depStop()</code></dt><dd>qui retourne l'arrêt de départ du voyage, c.-à-d. celui de sa première étape,</dd>\n<dt><code>Stop arrStop()</code></dt><dd>qui retourne l'arrêt d'arrivée du voyage, c.-à-d. celui de sa dernière étape,</dd>\n<dt><code>LocalDateTime depTime()</code></dt><dd>qui retourne la date/heure de début du voyage, c.-à-d. celle de sa première étape,</dd>\n<dt><code>LocalDateTime arrTime()</code></dt><dd>qui retourne la date/heure de fin du voyage, c.-à-d. celle de sa dernière étape,</dd>\n<dt><code>Duration duration()</code></dt><dd>qui retourne la durée totale du voyage, c.-à-d. celle séparant la date/heure de fin de celle de début.</dd>\n</dl>\n<p>\nLa classe <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/time/LocalDateTime.html\"><code>LocalDateTime</code></a>, qui représente un couple date/heure sans indication de fuseau horaire, fait partie de la bibliothèque Java. Cette classe jouera un rôle très important dans ce projet, et il est donc conseillé de prendre un moment pour lire <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/time/LocalDateTime.html\">sa documentation</a>.\n</p>\n</div>"
      },
      {
        "name": "Journey.Leg",
        "header": "3.8. Interface Journey.Leg",
        "content": "<div class=\"outline-text-3\" id=\"text-sec/java/leg\">\n<p>\nL'interface <code>Leg</code>, publique et imbriquée dans l'enregistrement <code>Journey</code>, représente une étape d'un voyage. Cette interface est implémentée par deux enregistrements, <code>Transport</code> (décrit à la §<a href=\"#sec/java/transport\">3.10</a>) et <code>Foot</code> (décrit à la §<a href=\"#sec/java/foot\">3.11</a>), qui correspondent aux deux types d'étapes — en transport et à pied.\n</p>\n<p>\nL'interface <code>Leg</code> offre les méthodes suivantes, toutes abstraites sauf la dernière :\n</p>\n<dl class=\"org-dl\">\n<dt><code>Stop depStop()</code></dt><dd>qui retourne l'arrêt de départ de l'étape,</dd>\n<dt><code>LocalDateTime depTime()</code></dt><dd>qui retourne la date/heure de départ de l'étape,</dd>\n<dt><code>Stop arrStop()</code></dt><dd>qui retourne l'arrêt d'arrivée de l'étape,</dd>\n<dt><code>LocalDateTime arrTime()</code></dt><dd>qui retourne la date/heure d'arrivée de l'étape,</dd>\n<dt><code>List&lt;IntermediateStop&gt; intermediateStops()</code></dt><dd>qui retourne la liste des arrêts intermédiaires de l'étape, le type <code>IntermediateStop</code> étant décrit à la §<a href=\"#sec/java/intermediate-stop\">3.9</a>,</dd>\n<dt><code>default Duration duration()</code></dt><dd>qui retourne la durée de l'étape.</dd>\n</dl>\n<p>\nLa classe <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/time/Duration.html\"><code>Duration</code></a>, qui représente une durée, est une classe de la bibliothèque Java qui provient du même paquetage que <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/time/LocalDateTime.html\"><code>LocalDateTime</code></a> (<code>java.time</code>). La lecture de <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/time/Duration.html\">sa documentation</a> est aussi fortement recommandée.\n</p>\n</div>"
      },
      {
        "name": "Journey.Leg.IntermediateStop",
        "header": "3.9. Enregistrement Journey.Leg.IntermediateStop",
        "content": "<div class=\"outline-text-3\" id=\"text-sec/java/intermediate-stop\">\n<p>\nL'enregistrement <code>IntermediateStop</code>, public et imbriqué dans l'interface <code>Leg</code>, représente un arrêt intermédiaire d'une étape. Il s'agit d'un arrêt auquel le moyen de transport utilisé s'arrête effectivement, mais qui se trouve entre l'arrêt de départ et l'arrêt d'arrivée de l'étape. Cet enregistrement possède les attributs suivants :\n</p>\n<dl class=\"org-dl\">\n<dt><code>Stop stop</code></dt><dd>l'arrêt intermédiaire en question,</dd>\n<dt><code>LocalDateTime arrTime</code></dt><dd>la date/heure d'arrivée à l'arrêt,</dd>\n<dt><code>LocalDateTime depTime</code></dt><dd>la date/heure de départ de l'arrêt.</dd>\n</dl>\n<p>\n<code>IntermediateStop</code> possède un constructeur compact qui valide les arguments en vérifiant que :\n</p>\n<ul class=\"org-ul\">\n<li><code>stop</code> n'est pas <code>null</code> (avec <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Objects.html#requireNonNull(T)\"><code>requireNonNull</code></a>),</li>\n<li>la date/heure de départ n'est pas antérieure à celle d'arrivée (attention, les deux peuvent être égales !).</li>\n</ul>\n<p>\nNotez que, comme il s'agit d'un arrêt intermédiaire, le véhicule y arrive avant d'en repartir, raison pour laquelle la date/heure d'arrivée doit précéder (ou être identique à) celle de départ.\n</p>\n<p>\nComme d'habitude, une <code>NullPointerException</code> est levée si la première vérification échoue, et une <code>IllegalArgumentException</code> si la seconde échoue.\n</p>\n</div>"
      },
      {
        "name": "Journey.Leg.Transport",
        "header": "3.10. Enregistrement Journey.Leg.Transport",
        "content": "<div class=\"outline-text-3\" id=\"text-sec/java/transport\">\n<p>\nL'enregistrement <code>Transport</code>, public et imbriqué dans l'interface <code>Leg</code>, représente une étape effectuée en transport public. Il implémente donc <code>Leg</code> et possède les attributs suivants :\n</p>\n<dl class=\"org-dl\">\n<dt><code>Stop depStop</code></dt><dd>l'arrêt de départ de l'étape,</dd>\n<dt><code>LocalDateTime depTime</code></dt><dd>la date/heure de départ de l'étape,</dd>\n<dt><code>Stop arrStop</code></dt><dd>l'arrêt d'arrivée de l'étape,</dd>\n<dt><code>LocalDateTime arrTime</code></dt><dd>la date/heure d'arrivée de l'étape,</dd>\n<dt><code>List&lt;IntermediateStop&gt; intermediateStops</code></dt><dd>les éventuels arrêts intermédiaires de l'étape,</dd>\n<dt><code>Vehicle vehicle</code></dt><dd>le type de véhicule utilisé pour cette étape,</dd>\n<dt><code>String route</code></dt><dd>le nom de la ligne sur laquelle circule le véhicule utilisé pour cette étape,</dd>\n<dt><code>String destination</code></dt><dd>le nom de la destination finale du véhicule utilisé pour cette étape.</dd>\n</dl>\n<p>\nLe constructeur compact de <code>Transport</code> valide les arguments en vérifiant que :\n</p>\n<ul class=\"org-ul\">\n<li>aucun d'entre eux n'est <code>null</code>,</li>\n<li>la date/heure d'arrivée n'est pas antérieure à celle de départ.</li>\n</ul>\n<p>\nDe plus, il copie la liste des arrêts intermédiaires afin de garantir l'immuabilité de la classe.\n</p>\n<p>\n<code>Transport</code> ne possède aucune autre méthode que celles ajoutées automatiquement aux enregistrements par Java. Notez que ces méthodes ajoutées par Java sont celles qui implémentent les méthodes abstraites de l'interface <code>Leg</code>. Par exemple, la méthode d'accès pour l'attribut <code>depStop</code>, ajoutée automatiquement, implémente la méthode <code>depStop()</code> de <code>Leg</code>.\n</p>\n</div>"
      },
      {
        "name": "Journey.Leg.Foot",
        "header": "3.11. Enregistrement Journey.Leg.Foot",
        "content": "<div class=\"outline-text-3\" id=\"text-sec/java/foot\">\n<p>\nL'enregistrement <code>Foot</code>, public et imbriqué dans l'interface <code>Leg</code>, représente une étape effectuée à pied. Il implémente donc <code>Leg</code> et possède les attributs suivants :\n</p>\n<dl class=\"org-dl\">\n<dt><code>Stop depStop</code></dt><dd>l'arrêt de départ de l'étape,</dd>\n<dt><code>LocalDateTime depTime</code></dt><dd>la date/heure de départ de l'étape,</dd>\n<dt><code>Stop arrStop</code></dt><dd>l'arrêt d'arrivée de l'étape,</dd>\n<dt><code>LocalDateTime arrTime</code></dt><dd>la date/heure d'arrivée de l'étape.</dd>\n</dl>\n<p>\nLe constructeur compact de <code>Foot</code> fait les mêmes vérifications que celui de <code>Transport</code>. En plus de ce constructeur compact, <code>Foot</code> possède deux méthodes publiques :\n</p>\n<dl class=\"org-dl\">\n<dt><code>List&lt;IntermediateStop&gt; intermediateStops()</code></dt><dd>qui implémente la méthode abstraite correspondante de l'interface <code>Leg</code> et retourne une liste vide, car une étape à pied ne comporte jamais d'arrêts intermédiaires,</dd>\n<dt><code>boolean isTransfer()</code></dt><dd>qui retourne vrai ssi l'étape est un changement au sein de la même gare, c.-à-d. si le <i>nom</i> (!) de l'arrêt de départ est identique à celui de l'arrêt d'arrivée.</dd>\n</dl>\n<p>\nSoyez attentifs au fait qu'une étape à pied entre deux arrêts différents peut être considérée comme un changement si ces arrêts ont le même nom. Par exemple, une étape entre la voie 70 et la voie 1 de la gare de Lausanne est un changement, même si les arrêts sont différents. Seul le fait que le nom de (la gare de) ces deux arrêts soit identique compte.\n</p>\n</div>"
      },
      {
        "name": "s scellées en Java",
        "header": "3.12. Interfaces scellées en Java",
        "content": "<div class=\"outline-text-3\" id=\"text-sec/sealed-interface\">\n<p>\nEn Java, une interface peut normalement être implémentée par n'importe quelle classe. Par exemple, l'interface <code>Leg</code> déclarée ci-dessus pourrait très bien être implémentée par d'autres classes que celles déclarées à l'intérieur de <code>Leg</code> (<code>Transport</code> et <code>Foot</code>).\n</p>\n<p>\nDans ce cas particulier, cela n'est toutefois pas souhaitable, car nous savons que les seuls types d'étapes qui existent dans le projet sont ces deux-là. Il serait donc bien de pouvoir communiquer cela à Java, afin d'interdire la définition d'autres classes implémentant l'interface <code>Leg</code>.\n</p>\n<p>\nCela peut se faire en <b>scellant</b> (<i>seal</i>) l'interface <code>Leg</code>, simplement en ajoutant le mot-clef <code>sealed</code> à l'interface, ainsi :\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-java\">public sealed interface Leg { … }\n</pre>\n</div>\n<p>\nLorsqu'une interface est ainsi scellée, les seules classes qui ont le droit de l'implémenter sont celles se trouvant dans la même « unité de compilation », c.-à-d. le même fichier Java.\n</p>\n</div>"
      },
      {
        "name": "FormatterFr",
        "header": "3.13. Classe FormatterFr",
        "content": "<div class=\"outline-text-3\" id=\"text-3-13\">\n<p>\nLa classe <code>FormatterFr</code> du paquetage principal, publique, finale et non instanciable, contient des méthodes statiques permettant d'obtenir la représentation textuelle de différents types de données, au format décrit à la §<a href=\"#sec/text-repr\">2.4</a>. Il s'agit de :\n</p>\n<dl class=\"org-dl\">\n<dt><code>String formatDuration(Duration duration)</code></dt><dd>qui retourne la représentation textuelle, décrite à la §<a href=\"#sec/repr/duration\">2.4.1</a>, de la durée donnée,</dd>\n<dt><code>String formatTime(LocalDateTime dateTime)</code></dt><dd>qui retourne la représentation textuelle, décrite à la §<a href=\"#sec/repr/time\">2.4.2</a>, de l'heure de la date/heure donnée,</dd>\n<dt><code>String formatPlatformName(Stop stop)</code></dt><dd>qui retourne la représentation textuelle, décrite à la §<a href=\"#sec/repr/platform\">2.4.3</a>, de la voie ou quai de l'arrêt donné — ou une chaîne vide si l'arrêt en question est une gare, ou si son nom de voie/quai est vide,</dd>\n<dt><code>String formatLeg(Journey.Leg.Foot footLeg)</code></dt><dd>qui retourne la représentation textuelle, décrite à la §<a href=\"#sec/repr/foot\">2.4.4</a>, de l'étape à pied donnée,</dd>\n<dt><code>String formatLeg(Journey.Leg.Transport leg)</code></dt><dd>qui retourne la représentation textuelle, décrite à la §<a href=\"#sec/repr/transport\">2.4.5</a>, de l'étape en transport donnée,</dd>\n<dt><code>String formatRouteDestination(Journey.Leg.Transport transportLeg)</code></dt><dd>qui retourne la représentation textuelle, décrite à la §<a href=\"#sec/repr/route\">2.4.6</a>, de la ligne et du sens de parcours du véhicule emprunté pour effectuer l'étape donnée.</dd>\n</dl>\n</div>"
      }
    ],
    "other_subsections": [
      {
        "header": "3.1. Installation de Java et d'IntelliJ",
        "content": "<div class=\"outline-text-3\" id=\"text-3-1\">\n<p>\nAvant de commencer à programmer, il faut vous assurer que la version 21 de Java est bien installée sur votre ordinateur, car c'est celle qui sera utilisée pour ce projet.\n</p>\n<p>\nSi vous ne l'avez pas encore installée, rendez-vous sur <a href=\"https://adoptium.net/\">le site Web du projet Adoptium</a>, téléchargez le programme d'installation correspondant à votre système d'exploitation (macOS, Linux ou Windows), et exécutez-le.\n</p>\n<p>\nCela fait, si vous n'avez pas encore installé IntelliJ, téléchargez la version <b>Community Edition</b> — et <b>pas</b> la version Ultimate qui apparaît au sommet de la page — depuis <a href=\"https://www.jetbrains.com/idea/download/\">le site de JetBrains</a> et installez-la.\n</p>\n</div>"
      },
      {
        "header": "3.2. Importation du squelette",
        "content": "<div class=\"outline-text-3\" id=\"text-3-2\">\n<p>\nUne fois Java et IntelliJ installés, vous pouvez télécharger <a href=\"f/rechor_skeleton.zip\">le squelette de projet que nous mettons à votre disposition</a>. Il s'agit d'une archive Zip dont vous devrez tout d'abord extraire le contenu à un emplacement de votre choix sur votre ordinateur. (Notez que certains navigateurs comme Safari extraient automatiquement le contenu de telles archives.)\n</p>\n<p>\nUne fois le contenu de l'archive extrait, vous constaterez qu'il se trouve en totalité dans un dossier nommé <code>ReCHor</code>. Lancez IntelliJ, choisissez <i>Open</i>, sélectionnez ce dossier, et finalement cliquez <i>Ok</i>.\n</p>\n<p>\nLe dossier <code>ReCHor</code> contient les sous-dossiers suivants :\n</p>\n<ul class=\"org-ul\">\n<li><code>resources</code>, destiné à contenir les « ressources » utiles au projet, en l'occurrence des icônes représentant les différents moyens de transport,</li>\n<li><code>src</code>, destiné à contenir le code source de votre projet, ainsi que divers fichiers que nous mettrons à votre disposition, et qui contient pour l'instant :\n<ul class=\"org-ul\">\n<li><code>SignatureChecks_1.java</code>, un fichier de vérification de signatures pour l'étape 1, qui ne devrait plus contenir d'erreur lorsque vous aurez terminé la rédaction de cette étape,</li>\n<li><code>Submit.java</code>, un programme qui vous permettra de rendre votre projet à la fin de chaque semaine,</li>\n</ul></li>\n<li><code>test</code>, destiné à contenir le code des tests unitaires de votre projet que nous vous fournirons ou que vous écrirez vous-même, et qui contient pour l'instant les tests de l'étape 1 — fournis exceptionnellement pour faciliter votre démarrage.</li>\n</ul>\n<p>\nLe dossier <code>resources</code> doit être marqué comme « dossier de ressources » pour qu'il soit correctement géré par IntelliJ. Pour cela, faites un clic droit sur lui puis sélectionnez <i>Mark Directory As</i> puis <i>Resources Root</i>. Vérifiez ensuite que le panneau <i>Project</i> d'IntelliJ ressemble à l'image ci-dessous.\n</p>\n<figure id=\"org813da36\">\n<img alt=\"intellij-project-skeleton;32.png\" class=\"shadowed\" src=\"i/intellij-project-skeleton;32.png\"/>\n<figcaption><span class=\"figure-number\">Figure 1 : </span>Projet IntelliJ après importation du squelette</figcaption>\n</figure>\n</div>"
      },
      {
        "header": "3.4. Type énuméré Vehicle",
        "content": "<div class=\"outline-text-3\" id=\"text-3-4\">\n<p>\nLe type énuméré <code>Vehicle</code> du sous-paquetage <code>journey</code> — donc du paquetage <code>ch.epfl.rechor.journey</code> — représente les différents types de véhicules de transport public en Suisse. Il comporte les sept valeurs suivantes, qui sont données ici dans l'ordre dans lequel elles doivent apparaître dans le type énuméré :\n</p>\n<dl class=\"org-dl\">\n<dt><code>TRAM</code></dt><dd>qui représente un tram,</dd>\n<dt><code>METRO</code></dt><dd>qui représente un métro,</dd>\n<dt><code>TRAIN</code></dt><dd>qui représente un train,</dd>\n<dt><code>BUS</code></dt><dd>qui représente un bus ou un car,</dd>\n<dt><code>FERRY</code></dt><dd>qui représente un bac ou un autre type de bateau,</dd>\n<dt><code>AERIAL_LIFT</code></dt><dd>qui représente une télécabine ou un autre type de transport aérien à câble,</dd>\n<dt><code>FUNICULAR</code></dt><dd>qui représente un funiculaire.</dd>\n</dl>\n<p>\nEn plus de ces valeurs, le type énuméré <code>Vehicle</code> offre l'attribut public, statique et final suivant :\n</p>\n<dl class=\"org-dl\">\n<dt><code>List&lt;Vehicle&gt; ALL</code></dt><dd>une liste immuable contenant la totalité des valeurs du type énuméré, dans leur ordre de définition (voir les conseils de programmation ci-dessous).</dd>\n</dl>\n</div>"
      },
      {
        "header": "3.14. Tests",
        "content": "<div class=\"outline-text-3\" id=\"text-3-14\">\n<p>\nPour vous aider à démarrer ce projet, des tests unitaires JUnit vous sont exceptionnellement fournis pour cette étape, et se trouvent dans le dossier <code>test</code> du squelette. Une fois que vous aurez terminé la rédaction des classes de cette étape, vous pourrez les exécuter en :\n</p>\n<ul class=\"org-ul\">\n<li>ajoutant JUnit à votre projet, comme expliqué dans <a href=\"../g/intellij-junit.html\">notre guide à ce sujet</a>,</li>\n<li>effectuant un clic droit sur le dossier <code>test</code> du projet et sélectionnant <i>Run 'All Tests'</i>.</li>\n</ul>\n</div>"
      },
      {
        "header": "3.15. Documentation",
        "content": "<div class=\"outline-text-3\" id=\"text-3-15\">\n<p>\nUne fois les tests exécutés avec succès, il vous reste à documenter la totalité des entités publiques (classes, attributs et méthodes) définies dans cette étape, au moyen de commentaires Javadoc, comme décrit dans <a href=\"../g/javadoc.html\">le guide consacré à ce sujet</a>. Vous pouvez écrire ces commentaires en français ou en anglais, en fonction de votre préférence, mais <b>vous ne devez utiliser qu'une seule langue pour tout le projet</b>.\n</p>\n</div>"
      }
    ]
  }
}