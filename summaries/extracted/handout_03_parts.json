{
  "intro": {
    "title": "Horaire et frontière de Pareto",
    "subtitle": "ReCHor – étape 3",
    "content": "<div class=\"outline-text-2\" id=\"text-1\">\n<p>\nLe but de cette troisième étape est double : d'une part définir des interfaces représentant l'horaire de transport public et ses composants ; d'autre part, écrire une classe permettant de représenter ce que l'on nomme la frontière de Pareto, et qui joue un rôle crucial dans l'algorithme de recherche de voyages optimaux.\n</p>\n</div>"
  },
  "concepts": {
    "header": "2.1. Horaire",
    "subsections": [
      {
        "header": "2.1. Horaire",
        "content": "<div class=\"outline-text-3\" id=\"text-2-1\">\n<p>\nLes données horaires que nous utiliserons dans ce projet pour rechercher les voyages optimaux sont une version légèrement simplifiée de celles de l'horaire suisse officiel. Elles sont constituées de :\n</p>\n<ul class=\"org-ul\">\n<li>l'ensemble des liaisons (concept décrit plus bas) effectuées un jour donné,</li>\n<li>l'ensemble des courses effectuées un jour donné,</li>\n<li>l'ensemble des lignes existantes,</li>\n<li>l'ensemble des arrêts existants, constitué de deux sous-ensembles disjoints, celui des gares et celui des voies/quais,</li>\n<li>l'ensemble des noms alternatifs des gares, c.-à-d. des noms qui permettent d'identifier une gare mais qui ne sont pas son nom officiel (p. ex. <i>Losanna</i>, le nom italien de <i>Lausanne</i>, est un nom alternatif de la gare de Lausanne dans les données que nous utiliserons),</li>\n<li>l'ensemble des changements qu'il est possible d'effectuer, à pied, soit au sein d'une même gare, soit entre deux gares distinctes mais voisines.</li>\n</ul>\n<p>\nCes différents concepts ont déjà été introduits dans les étapes précédentes, sauf celui de <b>liaison</b> (<i>connection</i>), qui est un trajet effectué par un véhicule de transport en commun entre deux arrêts successifs, c.-à-d. sans arrêt intermédiaire. Une course n'est donc rien d'autre qu'une succession de liaisons.\n</p>\n<p>\nPar exemple, nous avons vu que <a href=\"https://network.sbb.ch/fr/ligne/IR15\">la ligne IR 15 des CFF</a> relie Genève-Aéroport à Lucerne. De nombreux trains parcourent cette ligne chaque jour, chacun effectuant une course dans l'un des deux sens possible. Par exemple, le lundi 24 février 2025, un train effectuera une course partant de Genève-Aéroport à 9h45 et arrivant à Lucerne à 13h01. Lors de cette course, il s'arrêtera à 10 arrêts intermédiaires, les 5 premiers étant Genève, Nyon, Morges, Lausanne et Palézieux. Dès lors, cette course est constituée de 11 liaisons, les cinq premières étant :\n</p>\n<ol class=\"org-ol\">\n<li>celle partant de Genève-Aéroport à 9h45 et arrivant à Genève à 9h52,</li>\n<li>celle partant de Genève à 9h54 et arrivant à Nyon à 10h07,</li>\n<li>celle partant de Nyon à 10h09 et arrivant à Morges à 10h24,</li>\n<li>celle partant de Morges à 10h26 et arrivant à Lausanne à 10h37,</li>\n<li>celle partant de Lausanne à 10h40 et arrivant à Palézieux à 10h56.</li>\n</ol>\n<p>\nComme cet exemple l'illustre, une course comportant un total de <i>n</i> arrêts — en comptant les deux aux extrémités — est constituée de <i>n</i> – 1 liaisons.\n</p>\n</div>"
      },
      {
        "header": "2.2. Frontière de Pareto",
        "content": "<div class=\"outline-text-3\" id=\"text-2-2\">\n<p>\nNous avons vu à l'étape précédente que la recherche de voyages optimaux se fait en considérant trois critères : l'heure de départ, l'heure d'arrivée et le nombre de changements. Dans certains cas, qui seront décrits ultérieurement, seuls l'heure d'arrivée et le nombre de changements sont pris en compte.\n</p>\n<p>\nPour simplifier la discussion qui suit, nous ferons l'hypothèse que nous sommes justement dans une situation dans laquelle l'heure de départ n'est pas prise en compte. Notre but est donc uniquement d'optimiser l'heure d'arrivée \\(a\\) et le nombre de changements \\(c\\), que l'on désire tous deux minimiser afin d'arriver à destination aussi tôt, et en effectuant aussi peu de changements, que possible. Admettons maintenant que l'on ait les six possibilités suivantes pour se rendre à notre destination :\n</p>\n<ol class=\"org-ol\">\n<li>arriver à 8h00 en faisant 3 changements,</li>\n<li>arriver à 8h00 en faisant 4 changements,</li>\n<li>arriver à 8h01 en faisant 2 changements,</li>\n<li>arriver à 8h02 en faisant 1 changement,</li>\n<li>arriver à 8h03 en ne faisant aucun changement,</li>\n<li>arriver à 8h04 en faisant 1 changement.</li>\n</ol>\n<p>\nCes possibilités correspondent à l'ensemble de 6 paires \\((a, c)\\) suivant :\n</p>\n<p>\n\\[\\{(\\textrm{8h00}, 3), (\\textrm{8h00}, 4), (\\textrm{8h01}, 2), (\\textrm{8h02}, 1), (\\textrm{8h03}, 0), (\\textrm{8h04}, 1) \\} \\]\n</p>\n<p>\nEn examinant cet ensemble, on constate que certaines paires sont dominées par d'autres. Par exemple, la paire \\((\\textrm{8h00}, 4)\\) est dominée par la paire \\((\\textrm{8h00}, 3)\\). De même, la paire \\((\\textrm{8h04}, 1)\\) est dominée par les paires \\((\\textrm{8h03}, 0)\\) et \\((\\textrm{8h02}, 1)\\). Ces paires  dominées correspondent à des possibilités sans aucun intérêt pour le voyageur. Par exemple, la possibilité \\((\\textrm{8h00}, 4)\\) n'a aucun intérêt car la possibilité \\((\\textrm{8h00}, 3)\\), qui la domine, permet d'arriver à la même heure avec un changement de moins.\n</p>\n<p>\nSachant que les paires dominées ne sont pas intéressantes pour le voyageur, il semble raisonnable de ne conserver que celles qui ne le sont pas, et qui forment ce que l'on nomme la <b>frontière de Pareto</b> (<i>Pareto front</i> ou <i>Pareto frontier</i>).\n</p>\n<p>\nLa frontière de Pareto peut être visualisée sur un graphe dont l'axe horizontal représente l'heure d'arrivée et le vertical le nombre de changements, et sur lequel les différentes possibilités apparaissent comme des points. C'est ce qui a été fait à la figure <a href=\"#org0abd4d8\">3</a> ci-dessous, sur laquelle la zone dominée par chacun des points — un rectangle infini<sup><a class=\"footref\" href=\"#fn.2\" id=\"fnr.2\" role=\"doc-backlink\">2</a></sup> dont le point constitue le coin bas-gauche — a été coloriée en rouge partiellement transparent. On constate ainsi aisément que le point 2 se trouve dans la zone dominée par le point 1, et que le point 6 se trouve dans les zones dominées par les points 4 et 5. Il est dès lors facile de déterminer que la frontière de Pareto est constituée des points 1, 3, 4 et 5.\n</p>\n<figure id=\"org0abd4d8\">\n<img alt=\"pareto-front;16.png\" src=\"i/pareto-front;16.png\"/>\n<figcaption><span class=\"figure-number\">Figure 3 : </span>Frontière de Pareto</figcaption>\n</figure>\n<p>\nBien entendu, un graphique similaire pourrait être fait pour le cas où les critères d'optimisation incluent l'heure de départ. Il faudrait pour cela utiliser une troisième dimension, et les zones dominées seraient des cubes infinis.\n</p>\n</div>"
      },
      {
        "header": "2.3. Représentation des frontières immuables",
        "content": "<div class=\"outline-text-3\" id=\"text-2-3\">\n<p>\nL'algorithme de recherche de voyages optimaux que nous utiliserons calcule, étant donné un arrêt d'arrivée et une date de voyage, la frontière de Pareto de <i>tous</i> les voyages permettant d'atteindre cet arrêt ce jour-là, et ce pour chaque « gare » (au sens large) du réseau, ainsi que pour chaque course.\n</p>\n<p>\nSachant que les données que nous utiliserons comportent plus de 30 000 « gares » et 200 000 courses par jour, il importe de représenter les frontières de Pareto de manière efficace. Nous utiliserons donc une représentation optimisée, basée bien entendu sur les critères empaquetés de l'étape précédente.\n</p>\n<p>\nComme un tuple (paire ou triplet) de critères (augmenté) est représenté par une valeur de type <code>long</code>, et qu'une frontière de Pareto est un ensemble de critères, il semble logique d'utiliser un tableau de type <code>long[]</code> pour représenter une telle frontière. Une fois cette décision prise, la question qui se pose est de savoir si l'ordre dans lequel les critères apparaissent dans le tableau est important ou non.\n</p>\n<p>\nA priori, étant donné que les éléments d'un ensemble ne sont pas ordonnés en mathématiques, on pourrait penser que l'ordre dans lequel les tuples sont stockés dans le tableau importe peu. Et cela est effectivement le cas lorsque les frontières de Pareto que l'on désire représenter sont immuables. Toutefois, pour représenter des frontières de Pareto non immuables — des bâtisseurs de frontières, en réalité — il peut être intéressant d'ordonner les tuples de manière à obtenir des performances aussi bonnes que possible.\n</p>\n</div>"
      },
      {
        "header": "2.4. Représentation des frontières non immuables",
        "content": "<div class=\"outline-text-3\" id=\"text-2-4\">\n<p>\nL'algorithme de recherche utilisé par ReCHor construit petit à petit les frontières de Pareto correspondant aux voyages optimaux, et ce pour chaque gare et chaque course.\n</p>\n<p>\nEn d'autres termes, il commence avec des frontières de Pareto vides associées à chaque gare et course, puis leur ajoute progressivement des tuples correspondant à des voyages nouvellement découverts. Chaque fois qu'un nouveau tuple est ajouté à une frontière, deux cas peuvent se présenter :\n</p>\n<ol class=\"org-ol\">\n<li>le nouveau tuple est dominé par au moins un tuple de la frontière, auquel cas le nouveau tuple n'appartient pas à la frontière, qui ne change donc pas,</li>\n<li>le nouveau tuple n'est dominé par aucun tuple de la frontière, auquel cas il lui est ajouté, tandis que les éventuels tuples dominés par le nouveau en sont retirés.</li>\n</ol>\n<p>\nPour illustrer ce processus, voyons comment une frontière de Pareto initialement vide évolue si on lui ajoute les tuples plus haut, dans l'ordre 1, 2, 6, 3, 4, 5 :\n</p>\n<ol class=\"org-ol\">\n<li>initialement, la frontière est vide : \\(\\{\\}\\),</li>\n<li>on lui ajoute le tuple 1, \\((\\textrm{8h00}, 3)\\), qui n'est dominé par aucun de la frontière (vide), et qui n'en domine aucun autre, donc la frontière ne contient maintenant que lui : \\(\\{(\\textrm{8h00}, 3)\\}\\),</li>\n<li>on lui ajoute le tuple 2, \\((\\textrm{8h00}, 4)\\), qui est dominé par le seul tuple de la frontière, donc elle ne change pas : \\(\\{(\\textrm{8h00}, 3)\\}\\),</li>\n<li>on lui ajoute le tuple 6, \\((\\textrm{8h04}, 1)\\), qui n'est dominé par aucun de la frontière, et qui n'en domine aucun autre, donc la frontière devient : \\(\\{(\\textrm{8h00}, 3), (\\textrm{8h04}, 1)\\}\\),</li>\n<li>on lui ajoute le tuple 3, \\((\\textrm{8h01}, 2)\\), qui n'est dominé par aucun de la frontière, et qui n'en domine aucun autre, donc la frontière devient : \\(\\{(\\textrm{8h00}, 3), (\\textrm{8h01}, 2), (\\textrm{8h04}, 1)\\}\\),</li>\n<li>on lui ajoute le tuple 4, \\((\\textrm{8h02}, 1)\\), qui n'est dominé par aucun de la frontière, mais qui domine le tuple \\((\\textrm{8h04}, 1)\\), qui doit donc être supprimé de la frontière, qui devient : \\(\\{(\\textrm{8h00}, 3), (\\textrm{8h01}, 2), (\\textrm{8h02}, 1)\\}\\),</li>\n<li>on lui ajoute le tuple 5, \\((\\textrm{8h03}, 0)\\), qui n'est dominé par aucun de la frontière, et qui n'en domine aucun autre, donc la frontière devient : \\(\\{(\\textrm{8h00}, 3), (\\textrm{8h01}, 2), (\\textrm{8h02}, 1), (\\textrm{8h03}, 0)\\}\\).</li>\n</ol>\n<p>\nDans cet exemple, les éléments de la frontière ont toujours été placés dans l'<b>ordre lexicographique</b> (<i>lexical order</i>), c.-à-d. triés d'abord par heure d'arrivée (croissante) puis par nombre de changements (croissant). Le fait de toujours ordonner les tuples de la frontière ainsi est intéressant car cela permet d'ajouter un nouvel élément de manière relativement efficace.\n</p>\n<p>\nEn effet, lorsqu'on désire ajouter un nouveau tuple à une frontière dont les tuples sont ordonnés en ordre lexicographique, on sait que tous les tuples qui pourraient dominer le nouveau se trouvent forcément <i>avant</i> la position à laquelle le nouveau devrait être inséré.\n</p>\n<p>\nOn peut s'en convaincre en regardant la figure <a href=\"#org3de609a\">4</a> ci-dessous, qui montre la totalité des points entre \\((\\textrm{8h00}, 0)\\) et \\((\\textrm{8h05}, 4)\\). L'ordre de parcours lexicographique est indiqué par les flèches traitillées. De plus, le point correspondant à \\((\\textrm{8h02}, 2)\\) est colorié en noir, tous ceux qui le précèdent dans l'ordre lexicographique en rouge, et tous ceux qui le suivent en bleu.\n</p>\n<figure id=\"org3de609a\">\n<img alt=\"pareto-front-lexical;32.png\" src=\"i/pareto-front-lexical;32.png\"/>\n<figcaption><span class=\"figure-number\">Figure 4 : </span>Parcours des points dans l'ordre lexicographique</figcaption>\n</figure>\n<p>\nEn regardant cette figure, il devrait être clair que les seuls points qui peuvent dominer le noir sont les rouges, c.-à-d. ceux qui le précèdent dans l'ordre lexicographique. A l'inverse, les seuls points que le noir peut dominer sont les bleus, c.-à-d. ceux qui le suivent dans l'ordre lexicographique.\n</p>\n<p>\nPour résumer, en stockant les tuples composant une frontière de Pareto dans l'ordre lexicographique, on peut ajouter un nouveau tuple de manière assez efficace en procédant ainsi :\n</p>\n<ol class=\"org-ol\">\n<li>on parcourt tous les tuples de la frontière se trouvant avant celui à insérer dans l'ordre lexicographique,</li>\n<li>si, lors de ce parcours, un tuple dominant ou égal au nouveau est trouvé, on termine immédiatement l'ajout, car le nouveau tuple n'appartient pas à la frontière,</li>\n<li>une fois tous les tuples précédents parcourus, on parcourt tous ceux qui suivent le nouveau, et on élimine de la frontière tous ceux qui sont dominés par lui.</li>\n</ol>\n<p>\nDès lors, dans ce projet, nous ordonnerons toujours les tuples des (bâtisseurs de) frontières de Pareto en ordre lexicographique. Il faut noter que le format d'empaquetage que nous avons choisi rend cela extrêmement simple, car un tuple \\(t_1\\) se trouve avant un autre tuple \\(t_2\\) dans l'ordre lexicographique si et seulement si la version empaquetée de \\(t_1\\), interprétée comme un entier, est plus petite que la version empaquetée de \\(t_2\\).\n</p>\n</div>"
      }
    ]
  },
  "implementation": {
    "header": "3.1. Interface Indexed",
    "classes": [
      {
        "name": "Indexed",
        "header": "3.1. Interface Indexed",
        "content": "<div class=\"outline-text-3\" id=\"text-3-1\">\n<p>\nL'interface <code>Indexed</code>, du sous-paquetage <code>timetable</code>, est destinée à être étendue par toutes les interfaces représentant des données indexées. Par « données indexées » on entend toutes les données de l'horaire qui, conceptuellement en tout cas, sont stockées dans un tableau et identifiées par un index allant de 0 (inclus) à la taille du tableau (exclue).\n</p>\n<p>\n<code>Indexed</code> ne possède qu'une seule méthode (publique et abstraite) :\n</p>\n<dl class=\"org-dl\">\n<dt><code>int size()</code></dt><dd>qui retourne la taille — c.-à-d. le nombre d'éléments — des données.</dd>\n</dl>\n</div>"
      },
      {
        "name": "Stations",
        "header": "3.2. Interface Stations",
        "content": "<div class=\"outline-text-3\" id=\"text-3-2\">\n<p>\nL'interface <code>Stations</code> du sous-paquetage <code>timetable</code>, publique et étendant <code>Indexed</code>, représente des gares indexées. Elle possède les méthodes abstraites suivantes :\n</p>\n<dl class=\"org-dl\">\n<dt><code>String name(int id)</code></dt><dd>qui retourne le nom de la gare d'index donné,</dd>\n<dt><code>double longitude(int id)</code></dt><dd>qui retourne la longitude, en degrés, de la gare d'index donné,</dd>\n<dt><code>double latitude(int id)</code></dt><dd>qui retourne la latitude, en degrés, de la gare d'index donné.</dd>\n</dl>\n<p>\nToutes ces méthodes lèvent une <code>IndexOutOfBoundsException</code> si l'index qu'on leur passe (nommé <code>id</code> ci-dessous) est invalide, c.-à-d. inférieur à 0 ou supérieur ou égal à la taille retournée par <code>size()</code>.\n</p>\n</div>"
      },
      {
        "name": "StationAliases",
        "header": "3.3. Interface StationAliases",
        "content": "<div class=\"outline-text-3\" id=\"text-3-3\">\n<p>\nL'interface <code>StationAliases</code> du sous-paquetage <code>timetable</code>, publique et étendant <code>Indexed</code>, représente les noms alternatifs des gares. Elle possède les méthodes abstraites suivantes :\n</p>\n<dl class=\"org-dl\">\n<dt><code>String alias(int id)</code></dt><dd>qui retourne le nom alternatif d'index donné (p. ex. <code>Losanna</code>),</dd>\n<dt><code>String stationName(int id)</code></dt><dd>qui retourne le nom de la gare à laquelle correspond le nom alternatif d'index donné (p. ex. <code>Lausanne</code>).</dd>\n</dl>\n<p>\nToutes ces méthodes lèvent une <code>IndexOutOfBoundsException</code> si l'index qu'on leur passe (nommé <code>id</code> ci-dessous) est invalide, c.-à-d. inférieur à 0 ou supérieur ou égal à la taille retournée par <code>size()</code>.\n</p>\n</div>"
      },
      {
        "name": "Platforms",
        "header": "3.4. Interface Platforms",
        "content": "<div class=\"outline-text-3\" id=\"text-3-4\">\n<p>\nL'interface <code>Platforms</code> du sous-paquetage <code>timetable</code>, publique et étendant <code>Indexed</code>, représente des voies/quais indexés. Elle possède les méthodes abstraites suivantes :\n</p>\n<dl class=\"org-dl\">\n<dt><code>String name(int id)</code></dt><dd>qui retourne le nom de la voie (p. ex. <code>70</code>) ou du quai (p. ex. <code>A</code>), qui peut être vide,</dd>\n<dt><code>int stationId(int id)</code></dt><dd>qui retourne l'index de la gare à laquelle cette voie ou ce quai appartient.</dd>\n</dl>\n<p>\nToutes ces méthodes lèvent une <code>IndexOutOfBoundsException</code> si l'index qu'on leur passe (nommé <code>id</code> ci-dessous) est invalide, c.-à-d. inférieur à 0 ou supérieur ou égal à la taille retournée par <code>size()</code>.\n</p>\n</div>"
      },
      {
        "name": "Routes",
        "header": "3.5. Interface Routes",
        "content": "<div class=\"outline-text-3\" id=\"text-3-5\">\n<p>\nL'interface <code>Routes</code> du sous-paquetage <code>timetable</code>, publique et étendant <code>Indexed</code>, représente des lignes de transport public indexées. Elle possède les méthodes abstraites suivantes :\n</p>\n<dl class=\"org-dl\">\n<dt><code>Vehicle vehicle(int id)</code></dt><dd>qui retourne le type de véhicule desservant la ligne d'index donné,</dd>\n<dt><code>String name(int id)</code></dt><dd>qui retourne le nom de la ligne d'index donné (p. ex. IR 15).</dd>\n</dl>\n<p>\nToutes ces méthodes lèvent une <code>IndexOutOfBoundsException</code> si l'index qu'on leur passe (nommé <code>id</code> ci-dessous) est invalide, c.-à-d. inférieur à 0 ou supérieur ou égal à la taille retournée par <code>size()</code>.\n</p>\n</div>"
      },
      {
        "name": "Transfers",
        "header": "3.6. Interface Transfers",
        "content": "<div class=\"outline-text-3\" id=\"text-3-6\">\n<p>\nL'interface <code>Transfers</code> du sous-paquetage <code>timetable</code>, publique et étendant <code>Indexed</code>, représente des changements indexés. Il faut noter que, dans les données que nous utiliserons, des changements ne sont possibles qu'entre (ou au sein de) gares, et pas entre des voies ou quais.\n</p>\n<p>\n<code>Transfers</code> possède les méthodes abstraites suivantes :\n</p>\n<dl class=\"org-dl\">\n<dt><code>int depStationId(int id)</code></dt><dd>qui retourne l'index de la gare de départ du changement d'index donné,</dd>\n<dt><code>int minutes(int id)</code></dt><dd>qui retourne la durée, en minutes, du changement d'index donné,</dd>\n<dt><code>int arrivingAt(int stationId)</code></dt><dd>qui retourne l'intervalle empaqueté — selon la convention utilisée par <code>PackedRange</code> — des index des changements dont la gare d'arrivée est celle d'index donné,</dd>\n<dt><code>int minutesBetween(int depStationId, int arrStationId)</code></dt><dd>qui retourne la durée, en minutes, du changement entre les deux gares d'index donnés, ou lève <code>NoSuchElementException</code> si aucun changement n'est possible entre ces deux gares.</dd>\n</dl>\n<p>\nToutes ces méthodes lèvent une <code>IndexOutOfBoundsException</code> si l'un des index qu'on leur passe est invalide.\n</p>\n</div>"
      },
      {
        "name": "Trips",
        "header": "3.7. Interface Trips",
        "content": "<div class=\"outline-text-3\" id=\"text-3-7\">\n<p>\nL'interface <code>Trips</code> du sous-paquetage <code>timetable</code>, publique et étendant <code>Indexed</code>, représente des courses de transport public indexées. Elle possède les méthodes abstraites suivantes :\n</p>\n<dl class=\"org-dl\">\n<dt><code>int routeId(int id)</code></dt><dd>qui retourne l'index de la ligne à laquelle la course d'index donné appartient,</dd>\n<dt><code>String destination(int id)</code></dt><dd>qui retourne le nom de la destination finale de la course.</dd>\n</dl>\n<p>\nToutes ces méthodes lèvent une <code>IndexOutOfBoundsException</code> si l'index qu'on leur passe (nommé <code>id</code> ci-dessous) est invalide, c.-à-d. inférieur à 0 ou supérieur ou égal à la taille retournée par <code>size()</code>.\n</p>\n</div>"
      },
      {
        "name": "Connections",
        "header": "3.8. Interface Connections",
        "content": "<div class=\"outline-text-3\" id=\"text-3-8\">\n<p>\nL'interface <code>Connections</code> du sous-paquetage <code>timetable</code>, publique et étendant <code>Indexed</code>, représente des liaisons indexées. Pour les besoins de l'algorithme de recherche de voyages, les liaisons doivent être ordonnées par heure de départ décroissante.\n</p>\n<p>\n<code>Connections</code> possède les méthodes abstraites suivantes :\n</p>\n<dl class=\"org-dl\">\n<dt><code>int depStopId(int id)</code></dt><dd>qui retourne l'index de l'arrêt de départ de la liaison d'index donné,</dd>\n<dt><code>int depMins(int id)</code></dt><dd>qui retourne l'heure de départ de la liaison d'index donné, exprimée en minutes après minuit,</dd>\n<dt><code>int arrStopId(int id)</code></dt><dd>qui retourne l'index de l'arrêt d'arrivée de la liaison d'index donné,</dd>\n<dt><code>int arrMins(int id)</code></dt><dd>qui retourne l'heure d'arrivée de la liaison d'index donné, exprimée en minutes après minuit,</dd>\n<dt><code>int tripId(int id)</code></dt><dd>qui retourne l'index de la course à laquelle appartient la liaison d'index donné,</dd>\n<dt><code>int tripPos(int id)</code></dt><dd>qui retourne la position de la liaison d'index donné dans la course à laquelle elle appartient, la première liaison d'une course ayant l'index 0,</dd>\n<dt><code>int nextConnectionId(int id)</code></dt><dd>qui retourne l'index de la liaison suivant celle d'index donné dans la course à laquelle elle appartient, ou l'index de la première liaison de la course si la liaison d'index donné est la dernière de la course.</dd>\n</dl>\n<p>\nToutes ces méthodes lèvent une <code>IndexOutOfBoundsException</code> si l'index qu'on leur passe (nommé <code>id</code> ci-dessous) est invalide, c.-à-d. inférieur à 0 ou supérieur ou égal à la taille retournée par <code>size()</code>.\n</p>\n<p>\nLes index des arrêts de départ et d'arrivée retournés par <code>depStopId</code> et <code>arrStopId</code> peuvent soit désigner des gares, soit des voies ou quais. Si un tel index est inférieur au nombre de gares existant dans l'horaire, alors il représente un index de gare. Sinon, il représente un index de voie ou de quai, qui peut être calculé en soustrayant de l'index d'arrêt le nombre de gares existant dans l'horaire.\n</p>\n<p>\nPar exemple, s'il y a 1000 gares et 2000 voies ou quais, l'index d'arrêt 500 représente la gare d'index 500, tandis que l'index d'arrêt 1700 représente l'index de la voie/quai 700.\n</p>\n</div>"
      },
      {
        "name": "TimeTable",
        "header": "3.9. Interface TimeTable",
        "content": "<div class=\"outline-text-3\" id=\"text-3-9\">\n<p>\nL'interface <code>TimeTable</code> du sous-paquetage <code>timetable</code>, publique, représente un horaire de transport public. Elle possède les méthodes abstraites suivantes :\n</p>\n<dl class=\"org-dl\">\n<dt><code>Stations stations()</code></dt><dd>qui retourne les gares indexées de l'horaire,</dd>\n<dt><code>StationAliases stationAliases()</code></dt><dd>qui retourne les noms alternatifs indexés des gares de l'horaire,</dd>\n<dt><code>Platforms platforms()</code></dt><dd>qui retourne les voies/quais indexées de l'horaire,</dd>\n<dt><code>Routes routes()</code></dt><dd>qui retourne les lignes indexées de l'horaire,</dd>\n<dt><code>Transfers transfers()</code></dt><dd>qui retourne les changements indexés de l'horaire,</dd>\n<dt><code>Trips tripsFor(LocalDate date)</code></dt><dd>qui retourne les courses indexées de l'horaire actives le jour donné,</dd>\n<dt><code>Connections connectionsFor(LocalDate date)</code></dt><dd>qui retourne les liaisons indexées de l'horaire actives le jour donné.</dd>\n</dl>\n<p>\nEn plus de ces méthodes abstraites, <code>TimeTable</code> possède également les méthodes par défaut suivantes :\n</p>\n<dl class=\"org-dl\">\n<dt><code>default boolean isStationId(int stopId)</code></dt><dd>qui retourne vrai si et seulement si l'index d'arrêt donné est un index de gare (et pas un index de voie ou de quai),</dd>\n<dt><code>default boolean isPlatformId(int stopId)</code></dt><dd>qui retourne vrai si et seulement si l'index d'arrêt donné est un index de voie ou de quai (et pas un index de gare),</dd>\n<dt><code>default int stationId(int stopId)</code></dt><dd>qui retourne l'index de la gare de l'arrêt d'index donné (qui peut être identique si l'arrêt en question est une gare),</dd>\n<dt><code>default String platformName(int stopId)</code></dt><dd>qui retourne le nom de voie ou de quai de l'arrêt d'index donné, ou <code>null</code> si cet arrêt est une gare.</dd>\n</dl>\n</div>"
      },
      {
        "name": "ParetoFront",
        "header": "3.10. Classe ParetoFront",
        "content": "<div class=\"outline-text-3\" id=\"text-3-10\">\n<p>\nLa classe <code>ParetoFront</code> du sous-paquetage <code>journey</code>, publique et immuable, représente une frontière de Pareto de critères d'optimisation. Les tuples de la frontière sont stockés sous forme empaquetée, dans un tableau de type <code>long[]</code> privé.\n</p>\n<p>\n<code>ParetoFront</code> possède l'attribut public, statique et final suivant :\n</p>\n<dl class=\"org-dl\">\n<dt><code>ParetoFront EMPTY</code></dt><dd>qui contient une frontière de Pareto vide.</dd>\n</dl>\n<p>\n<code>ParetoFront</code> ne possède pas de constructeur public, car ses instances ne sont destinées à être construites que par le bâtisseur décrit à la section suivante. Elle possède toutefois un constructeur privé qui prend en argument un tableau de type <code>long[]</code> contenant les critères empaquetés, qu'elle stocke <i>sans</i> le copier. Pour garantir l'immuabilité de la classe, il est donc fondamental que ce tableau ne change pas après l'appel du constructeur. En particulier, la méthode <code>build</code> du bâtisseur décrit plus bas doit garantir cela, en passant au constructeur une copie de son tableau interne.\n</p>\n<p>\nEn plus de ce constructeur privé, <code>ParetoFront</code> offre les méthodes publiques suivantes :\n</p>\n<dl class=\"org-dl\">\n<dt><code>int size()</code></dt><dd>qui retourne la taille de la frontière de Pareto, c.-à-d. le nombre de tuples (paires ou triplets de critères d'optimisation) qu'elle contient,</dd>\n<dt><code>long get(int arrMins, int changes)</code></dt><dd>qui retourne les critères d'optimisation empaquetés dont l'heure d'arrivée et le nombre de changements sont ceux donnés, ou lève une <code>NoSuchElementException</code> si ces critères ne font pas partie de la frontière,</dd>\n<dt><code>void forEach(LongConsumer action)</code></dt><dd>qui appelle la méthode <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/LongConsumer.html#accept(long)\"><code>accept</code></a> de l'action de type <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/LongConsumer.html\"><code>LongConsumer</code></a> donnée avec chacun des critères de la frontière, dans l'ordre.</dd>\n</dl>\n<p>\nEn plus de ces méthodes, il est <i>très fortement</i> conseillé d'ajouter à <code>ParetoFront</code> une redéfinition de la méthode <code>toString</code> qui produit une représentation textuelle de la frontière de Pareto, afin de faciliter le débogage. Le format de cette représentation textuelle n'est pas spécifié, mais il est conseillé de présenter les critères de la frontière de manière aussi lisible que possible, en montrant pour chacun d'eux l'heure de départ (si elle est présente), l'heure d'arrivée et le nombre de changements.\n</p>\n</div>"
      },
      {
        "name": "ParetoFront.Builder",
        "header": "3.11. Classe ParetoFront.Builder",
        "content": "<div class=\"outline-text-3\" id=\"text-3-11\">\n<p>\nLa classe <code>Builder</code> imbriquée statiquement dans <code>ParetoFront</code>, publique, représente un bâtisseur de frontière de Pareto. La frontière en cours de construction est stockée dans un tableau de type <code>long[]</code> qui contient les tuples et est « redimensionné » au besoin selon la technique décrite dans les conseils de programmation plus bas.\n</p>\n<p>\n<code>Builder</code> offre deux constructeurs publics :\n</p>\n<dl class=\"org-dl\">\n<dt><code>Builder()</code></dt><dd>qui retourne un bâtisseur dont la frontière en cours de construction est vide,</dd>\n<dt><code>Builder(Builder that)</code></dt><dd>qui retourne un nouveau bâtisseur avec les mêmes attributs que celui reçu en argument (constructeur de copie).</dd>\n</dl>\n<p>\nEn plus de ces constructeurs, <code>Builder</code> offre les méthodes publiques ci-dessous, toutes celles modifiant la frontière retournent le bâtisseur lui-même afin de permettre le chaînage des appels :\n</p>\n<dl class=\"org-dl\">\n<dt><code>boolean isEmpty()</code></dt><dd>qui retourne vrai si et seulement si la frontière en cours de construction est vide,</dd>\n<dt><code>Builder clear()</code></dt><dd>qui vide la frontière en cours de construction en supprimant tous ses éléments,</dd>\n<dt><code>Builder add(long packedTuple)</code></dt><dd>qui ajoute à la frontière le tuple de critères empaquetés donné ; cet ajout n'est fait que si le nouveau tuple n'est pas dominé ou égal à un de la frontière, et tous les éventuels tuples existants et dominés par le nouveau en sont supprimés,</dd>\n<dt><code>Builder add(int arrMins, int changes, int payload)</code></dt><dd>qui ajoute à la frontière un tuple de critères augmentés ayant l'heure d'arrivée, le nombre de changements et la charge utile donnés, mais pas d'heure de départ ; l'ajout est fait de la même manière que dans la méthode précédente,</dd>\n<dt><code>Builder addAll(Builder that)</code></dt><dd>qui ajoute à la frontière tous les tuples présents dans la frontière en cours de construction par le bâtisseur donné,</dd>\n<dt><code>boolean fullyDominates(Builder that, int depMins)</code></dt><dd>qui retourne vrai si et seulement si chacun des tuples de la frontière donnée, une fois son heure de départ fixée sur celle donnée, est dominé par, ou égal à, au moins un tuple du récepteur (le récepteur étant l'objet auquel on applique la méthode),</dd>\n<dt><code>void forEach(LongConsumer action)</code></dt><dd>qui fait la même chose que la méthode <code>forEach</code> de <code>ParetoFront</code>,</dd>\n<dt><code>ParetoFront build()</code></dt><dd>qui retourne la frontière de Pareto en cours de construction par ce bâtisseur.</dd>\n</dl>\n<p>\nTout comme pour <code>ParetoFront</code>, il est très fortement conseillé d'ajouter à <code>Builder</code> une redéfinition de la méthode <code>toString</code> afin de faciliter le débogage. La plupart du code peut être partagée entre les deux méthodes <code>toString</code>.\n</p>\n</div>"
      }
    ],
    "other_subsections": [
      {
        "header": "3.12. Tests",
        "content": "<div class=\"outline-text-3\" id=\"text-3-12\">\n<p>\nComme pour l'étape précédente, nous ne vous fournissons plus de tests mais <a href=\"f/SignatureChecks_3.java\">un fichier de vérification de signatures</a> à importer dans votre projet.\n</p>\n</div>"
      }
    ]
  }
}