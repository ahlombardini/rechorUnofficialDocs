{
  "intro": {
    "title": "Recherche de voyages optimaux",
    "subtitle": "ReCHor – étape 7",
    "content": "<div class=\"outline-text-2\" id=\"text-1\">\n<p>\nLe but principal de cette étape est d'écrire l'algorithme central du projet, qui recherche les voyages optimaux permettant de se rendre à un arrêt d'arrivée donné, un jour donné. Son but secondaire est d'écrire une classe permettant de stocker les données horaires dans ce que l'on nomme un <i>cache</i>, afin d'éviter de les recharger trop fréquemment.\n</p>\n</div>"
  },
  "concepts": {
    "header": "2.1. Algorithme CSA",
    "subsections": [
      {
        "header": "2.1. Algorithme CSA",
        "content": "<div class=\"outline-text-3\" id=\"text-sec/csa\">\n<p>\nAfin de calculer les voyages optimaux, nous utiliserons l'algorithme CSA<sup><a class=\"footref\" href=\"#fn.1\" id=\"fnr.1\" role=\"doc-backlink\">1</a></sup> (<i>connection scan algorithm</i>). Comme son nom le suggère, il effectue la recherche de voyages en parcourant la totalité des liaisons à l'horaire.\n</p>\n<p>\nCet algorithme se base sur l'observation que, si une liaison est ajoutée à un horaire mais qu'elle part <i>avant</i> toutes les liaisons existantes, alors les seuls voyages optimaux que son ajout peut affecter sont ceux partant de la gare de départ de cette liaison, ou d'une gare dont on peut y parvenir à pied.\n</p>\n<p>\nPar exemple, admettons qu'aucune liaison ne parte avant 8h du matin, et que nous ayons établi le profil de tous les voyages optimaux permettant de se rendre de n'importe quelle gare de Suisse à Gruyères. Imaginons maintenant qu'une nouvelle liaison soit ajoutée à l'horaire, et parte de Renens à 7h59 pour arriver à Lausanne à 8h04. Il devrait être clair que cet ajout ne peut, au mieux, qu'améliorer les voyages optimaux partant de Renens ou d'une gare depuis laquelle il est possible de marcher jusqu'à celle de Renens. Aucun autre voyage optimal ne peut être affecté, car la nouvelle liaison part avant toutes les autres et n'est donc pas atteignable depuis une ancienne liaison.\n</p>\n<p>\nDès lors, on peut déterminer la totalité des voyages optimaux permettant de se rendre à une destination donnée en partant d'un horaire vide auquel on ajoute petit à petit toutes les liaisons, par heure de départ décroissante. Ce faisant, on garde à jour l'ensemble des voyages optimaux actuels.\n</p>\n<p>\nComme nous l'avons vu, l'information concernant les voyages optimaux est stockée dans les frontières de Pareto des critères d'optimisation attachées aux gares. Lors de l'exécution de l'algorithme, ce sont donc ces frontières de Pareto qui sont mises à jour au fur et à mesure de l'ajout des liaisons. De plus, des frontières de Pareto associées aux différentes <i>courses</i> sont tenues à jour de manière identique, pour des raisons expliquées plus bas.\n</p>\n<p>\nPour chaque liaison ajoutée à l'horaire, l'algorithme CSA commence par déterminer la frontière de Pareto des voyages optimaux de la liaison elle-même, en utilisant le fait qu'une personne l'empruntant n'a que trois manière de continuer son voyage :\n</p>\n<ol class=\"org-ol\">\n<li>elle peut descendre à la fin de la liaison et marcher jusqu'à la destination finale, pour peu que celle-ci soit atteignable à pied depuis là,</li>\n<li>elle peut rester dans le véhicule afin de continuer avec la prochaine liaison de la même course (s'il y en a une),</li>\n<li>elle peut changer de véhicule à la fin de la liaison.</li>\n</ol>\n<p>\nUne fois que la frontière de Pareto des voyages optimaux de la liaison a été  déterminée, elle peut être utilisée pour mettre à jour les frontières de Pareto de :\n</p>\n<ul class=\"org-ul\">\n<li>la course à laquelle appartient la liaison, et</li>\n<li>toutes les gares depuis lesquelles il est possible de marcher pour atteindre la gare de départ de la liaison — y compris la gare de départ elle-même.</li>\n</ul>\n<p>\nLorsque toutes les liaisons ont été ajoutées, l'algorithme se termine, son résultat étant les frontières de Pareto des voyages optimaux des gares.\n</p>\n</div>"
      },
      {
        "header": "2.2. Mémoire cache",
        "content": "<div class=\"outline-text-3\" id=\"text-2-2\">\n<p>\nEn informatique, on nomme <b>mémoire cache</b> (<i>cache memory</i>), ou simplement <b>cache</b>, une mémoire dans laquelle on stocke une (copie d'une) donnée fréquemment utilisée, pour éviter de devoir la recalculer à chaque utilisation.\n</p>\n<p>\nDans ce projet, nous utiliserons un cache pour accélérer l'accès aux données horaires qui dépendent du jour, c.-à-d. les courses et les liaisons. Comme nous l'avons vu à l'étape précédente, ces données sont chargées — ou, plus exactement, « mappées » en mémoire — à chaque utilisation. Or il est très probable que les données horaires du même jour soient nécessaires plusieurs fois de suite, et en les plaçant dans un cache on évite leur rechargement — ou « re-mappage » en mémoire — ce qui peut améliorer considérablement les performances du programme.\n</p>\n<p>\nLe cache que nous utiliserons est particulièrement simple, puisqu'il ne mémorise que les données horaires d'un seul jour. On aurait pu imaginer un cache plus sophistiqué, mémorisant les données des <i>n</i> derniers jours, mais étant donné la manière dont le programme est généralement utilisé, cela ne s'avère pas utile.\n</p>\n</div>"
      }
    ]
  },
  "implementation": {
    "header": "3.1. Enregistrement Router",
    "classes": [
      {
        "name": "Router",
        "header": "3.1. Enregistrement Router",
        "content": "<div class=\"outline-text-3\" id=\"text-3-1\">\n<p>\nL'enregistrement <code>Router</code> du sous-paquetage <code>journey</code>, public et immuable, représente un « routeur », c.-à-d. un objet capable de calculer le profil de tous les voyages optimaux permettant de se rendre de n'importe quelle gare du réseau à un gare d'arrivée donnée, un jour donné. Il possède un seul attribut, de type <code>TimeTable</code>, qui contient les données horaires à utiliser.\n</p>\n<p>\nEn dehors des méthodes ajoutées automatiquement par Java aux enregistrements, <code>Router</code> possède une seule méthode publique, nommée p. ex. <code>profile</code>, qui prend en arguments :\n</p>\n<ul class=\"org-ul\">\n<li>la date pour laquelle les voyages optimaux doivent être calculés,</li>\n<li>l'identité de la gare de destination,</li>\n</ul>\n<p>\net retourne le profil de tous les voyages optimaux permettant de se rendre de n'importe quelle gare du réseau à celle de destination, le jour donné. Cette méthode utilise bien entendu l'algorithme CSA décrit plus haut.\n</p>\n</div>"
      },
      {
        "name": "CachedTimeTable",
        "header": "3.2. Classe CachedTimeTable",
        "content": "<div class=\"outline-text-3\" id=\"text-3-2\">\n<p>\nLa classe <code>CachedTimeTable</code> du sous-paquetage <code>timetable</code>, publique et immuable, implémente <code>TimeTable</code> et représente un horaire dont les données qui dépendent de la date — les courses et les liaisons — sont stockées dans un cache. De la sorte, si ces données sont demandées plusieurs fois de suite pour une seule et même date, elles ne sont pas rechargées à chaque fois.\n</p>\n<p>\n<code>CachedTimeTable</code> offre un constructeur prenant en argument l'horaire, de type <code>TimeTable</code>, dont les courses et liaisons doivent être stockées dans un cache. Nous appellerons cet horaire <b>l'horaire sous-jacent</b> (<i>underlying timetable</i>).\n</p>\n<p>\nEn dehors de ce constructeur, <code>CachedTimeTable</code> n'offre que les méthodes publiques de l'interface <code>TimeTable</code>.\n</p>\n</div>"
      }
    ],
    "other_subsections": [
      {
        "header": "3.3. Tests",
        "content": "<div class=\"outline-text-3\" id=\"text-3-3\">\n<p>\nPour tester votre calcul de voyages optimaux, vous pouvez écrire un programme similaire à celui ci-dessous pour afficher l'événement iCalendar correspondant à un voyage optimal. Avec les données horaires de la semaine 14, ce programme  devrait afficher un événement très similaire à celui de <a href=\"02.html#sec/ical/example\">la §2.1.8 de l'étape 2</a>.\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-java\">static int stationId(Stations stations, String stationName) {\n  // … laissé en exercice\n}\n\npublic static void main(String[] args) throws IOException {\n  long tStart = System.nanoTime();\n\n  TimeTable timeTable =\n    new CachedTimeTable(FileTimeTable.in(Path.of(\"timetable\")));\n  Stations stations = timeTable.stations();\n  LocalDate date = LocalDate.of(2025, Month.APRIL, 1);\n  int depStationId = stationId(stations, \"Ecublens VD, EPFL\");\n  int arrStationId = stationId(stations, \"Gruyères\");\n  Router router = new Router(timeTable);\n  Profile profile = router.profile(date, arrStationId);\n  Journey journey = JourneyExtractor\n    .journeys(profile, depStationId)\n    .get(32);\n  System.out.println(JourneyIcalConverter.toIcalendar(journey));\n\n  double elapsed = (System.nanoTime() - tStart) * 1e-9;\n  System.out.printf(\"Temps écoulé : %.3f s%n\", elapsed);\n}\n\n</pre>\n</div>\n<p>\nEn plus de l'évènement iCalendar, ce programme affiche le temps nécessaire à son exécution. Sur un MacBook Pro de 2020, ce temps se situe généralement autour des 2½ secondes, et si vous obtenez un résultat du même ordre de grandeur sur votre ordinateur, vous pouvez raisonnablement en conclure que votre programme n'a pas de gros problème de performance.\n</p>\n<p>\nBien entendu, vous pouvez également calculer les voyages optimaux entre des gares différentes, et comparer vos résultats avec ceux d'un site comme <a href=\"https://www.cff.ch/\">celui des CFF</a>.\n</p>\n<p>\nFinalement, vous pouvez aussi essayer de calculer le même profil que celui fourni à <a href=\"06.html\">l'étape 6</a>, le stocker dans un fichier textuel de format identique, et ensuite comparer le contenu des deux fichiers. IntelliJ permet de faire facilement de telles comparaison : il suffit de sélectionner les deux fichiers à comparer, puis à sélectionner <i>Compare files…</i> dans le menu contextuel.\n</p>\n<p>\nFaites toutefois attention au fait qu'il pourrait y avoir des différences non significatives dues à la manière dont la méthode <code>add</code> de votre classe <code>ParetoFront.Builder</code> gère le cas où on ajoute un tuple déjà présent dans la frontière en cours de construction. Le corrigé du projet, utilisé pour générer le profil de référence, conserve l'ancien tuple et sa charge utile, en ignorant le nouveau. Si votre mise en œuvre <i>remplace</i> le tuple existant par le nouveau — ce qui est aussi valide, bien que moins efficace — alors vous pourriez obtenir un profil différent mais néanmoins correct.\n</p>\n</div>"
      }
    ]
  }
}