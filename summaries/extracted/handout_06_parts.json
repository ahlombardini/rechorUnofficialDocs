{
  "intro": {
    "title": "Profil et extraction de voyage",
    "subtitle": "ReCHor – étape 6",
    "content": "<div class=\"outline-text-2\" id=\"text-1\">\n<p>\nLe but de cette sixième étape — la dernière de la première partie du projet — est d'une part de terminer la rédaction des classes représentant l'horaire aplati, et d'autre part d'écrire celles permettant de représenter ce que nous appellerons un <i>profil</i>, et d'en extraire des voyages.\n</p>\n<div class=\"cs108warning\" id=\"orga24b9f6\">\n<p>\nNotez que cette étape devra être rendue deux fois :\n</p>\n<ol class=\"org-ol\">\n<li>pour le rendu testé habituel (délai : le <b>28/3</b> à <b>18h00</b>),</li>\n<li>pour le rendu intermédiaire (délai : le <b>4/4</b> à <b>18h00</b>).</li>\n</ol>\n<p>\nLe deuxième de ces rendus sera corrigé par lecture du code de vos étapes 1 à 6, et il vous faudra donc soigner sa qualité et sa documentation. Il est fortement conseillé de lire <a href=\"../g/style.html\">notre guide à ce sujet</a>.\n</p>\n</div>\n</div>"
  },
  "concepts": {
    "header": "2.1. « Mappage » de fichiers en mémoire",
    "subsections": [
      {
        "header": "2.1. « Mappage » de fichiers en mémoire",
        "content": "<div class=\"outline-text-3\" id=\"text-2-1\">\n<p>\nLes deux étapes précédentes ont été consacrées à la rédaction de classes permettant de manipuler les différents éléments de l'horaire aplati — gares, voies/quais, liaisons, etc. — se trouvant dans des tableaux d'octets. Il reste à savoir comment obtenir ces tableaux d'octets.\n</p>\n<p>\nComme expliqué à la §<a href=\"#sec/implementation\">3</a>, nous mettons à votre disposition un certain nombre de fichiers dont le contenu correspond exactement à celui des tableaux d'octets attendus. Par exemple, un des fichiers que nous vous fournissons, nommé <code>stations.bin</code>, contient la totalité des gares aplaties au format décrit à <a href=\"04.html#sec/stations\">la §2.3 de l'étape 4</a>.\n</p>\n<p>\nIl serait donc techniquement possible de charger le contenu de ce fichier et de le placer dans un tableau d'octets — de type <code>ByteBuffer</code> — passé ensuite à la classe <code>BufferedStations</code>.  Cette solution aurait toutefois l'inconvénient de ralentir le démarrage du programme, la quantité de données à charger étant relativement grande.\n</p>\n<p>\nHeureusement, une autre solution existe, le « mappage » de fichier en mémoire (<i>memory mapping</i>). Cet anglicisme désigne la possibilité de faire apparaître le contenu d'un fichier en mémoire, comme s'il avait effectivement été chargé, mais sans qu'il ne le soit réellement. Au lieu de cela, le contenu du fichier n'est chargé que lorsqu'on accède aux données, et seules les parties effectivement nécessaires de ce contenu sont chargées.\n</p>\n<p>\nCette possibilité est intéressante, car elle nous permet d'écrire le programme comme si la totalité des données de l'horaire était chargée en mémoire au démarrage du programme, alors qu'en réalité seules les parties effectivement utilisées le sont, au moment de leur première utilisation.\n</p>\n</div>"
      },
      {
        "header": "2.2. Profil",
        "content": "<div class=\"outline-text-3\" id=\"text-2-2\">\n<p>\nComme nous le verrons à l'étape suivante, l'algorithme de recherche de voyage optimaux produit en résultat une table donnant, pour chaque gare du réseau, la frontière de Pareto des critères d'optimisation — heure de départ et d'arrivée, nombre de changements — des voyages permettant d'atteindre la destination choisie, le jour choisi. Nous nommerons cette table un <b>profil</b> (<i>profile</i>).\n</p>\n<p>\nPar exemple, si on utilise l'algorithme de recherche pour trouver les voyages optimaux permettant de se rendre à Gruyères le 18 février 2025, il produit un profil associant une frontière de Pareto à <i>chacune</i> des plus de 30 000 gares existantes. Parmi ces frontières figure celle correspondant à la gare <i>Ecublens VD, EPFL</i> et contenant, entre autres, les tuples suivant :\n</p>\n<p>\n\\[\n\\ldots,\n(\\textrm{15h55}, \\textrm{17h57}, 3),\n(\\textrm{16h13}, \\textrm{17h57}, 4),\n(\\textrm{16h38}, \\textrm{18h21}, 3),\n(\\textrm{16h38}, \\textrm{18h28}, 2),\n\\ldots\n\\]\n</p>\n<p>\nqui correspondent aux quatre premiers voyages visibles dans la copie d'écran de l'interface graphique finale du programme ci-dessous, déjà présentée dans l'introduction au projet.\n</p>\n<figure id=\"org946948d\">\n<img alt=\"rechor-gui.png\" class=\"shadowed\" src=\"i/rechor-gui.png\" width=\"100%\"/>\n<figcaption><span class=\"figure-number\">Figure 1 : </span>Voyages de <i>Ecublens VD, EPFL</i> à <i>Gruyères</i></figcaption>\n</figure>\n<p>\nIl est important de comprendre qu'un profil contient la frontière de Pareto de <i>chacune</i> des gares pour une destination et un jour de voyage donnés, et n'est donc pas lié à une gare de départ particulière.\n</p>\n</div>"
      },
      {
        "header": "2.3. Profil augmenté",
        "content": "<div class=\"outline-text-3\" id=\"text-2-3\">\n<p>\nUn profil contient, pour chaque gare, la frontière de Pareto de tous les voyages optimaux permettant de se rendre de cette gare-là à la gare de destination, à la date de voyage donnée. Il permet donc à un voyageur se trouvant dans une gare quelconque du réseau ce jour-là de déterminer quand il peut arriver à la destination, et au prix de combien de changements.\n</p>\n<p>\nLors du calcul des voyages optimaux, il se trouve qu'il est utile d'avoir cette information-là non seulement pour toutes les <i>gares</i> du réseau, mais aussi pour toutes les <i>courses</i> circulant ce jour-là. En d'autres termes, d'offrir un profil permettant également à un voyageur se trouvant à bord d'un véhicule effectuant une course donnée de déterminer quand il peut arriver à destination, et au prix de combien de changements. Contrairement aux frontières de Pareto associées aux gares, celles associées aux courses ne comportent que deux critères d'optimisation (l'heure d'arrivée et le nombre de changements), car l'heure de départ d'une course ne peut pas être choisie.\n</p>\n<p>\nNous appellerons <b>profil augmenté</b> un profil possédant non seulement les frontières de Pareto correspondant aux gares, mais aussi celles correspondant aux courses.\n</p>\n</div>"
      },
      {
        "header": "2.4. Extraction de voyages",
        "content": "<div class=\"outline-text-3\" id=\"text-2-4\">\n<p>\nÀ eux seuls, les tuples associés à une gare dans un profil ne contiennent pas assez d'information pour permettre à un voyageur de déterminer comment se rendre à destination. Par exemple, le tuple \\((\\textrm{15h55}, \\textrm{17h57}, 3)\\) de la frontière de Pareto donnée en exemple plus haut permet uniquement de savoir qu'il est possible de partir de l'EPFL à 15h55 pour arriver à Gruyères à 17h57 après avoir effectué 3 changements, mais sans savoir comment. Ainsi, si deux métros partent de l'EPFL à 15h55, l'un en direction de Renens, l'autre en direction de Lausanne, il est impossible de savoir lequel prendre sans autre information que le tuple.\n</p>\n<p>\nDès lors, pour pouvoir extraire d'un profil la totalité des voyages optimaux pour un arrêt de départ donné, des informations supplémentaires sont nécessaires. Ces informations seront calculées par l'algorithme de recherche des voyages optimaux, et stockées dans ce que nous avons appelé la charge utile (<i>payload</i>) associée aux tuples.\n</p>\n<p>\nPour les tuples des frontières de Pareto des gares, contenant trois critères (heure de départ et d'arrivée, nombre de changements), la charge utile contient deux informations :\n</p>\n<ul class=\"org-ul\">\n<li>l'identité de la première liaison à emprunter pour débuter le voyage,</li>\n<li>le nombre d'arrêts intermédiaires à laisser passer avant de descendre du véhicule.</li>\n</ul>\n<p>\nCes deux informations sont empaquetées dans les 32 bits de la charge utile, les 24 bits de poids fort contenant l'identité de la liaison, les 8 bits de poids faible contenant le nombre d'arrêts intermédiaires.\n</p>\n<p>\nPar exemple, au tuple \\((\\textrm{15h55}, \\textrm{17h57}, 3)\\) mentionné plus haut pourrait être associée une charge utile contenant :\n</p>\n<ul class=\"org-ul\">\n<li>l'identité de la liaison partant à 15h55 de <i>Ecublens VD, EPFL</i> pour arriver à 15h56 à <i>Ecublens VD, Bassenges</i>,</li>\n<li>un nombre d'arrêts intermédiaires valant 4.</li>\n</ul>\n<p>\nGrâce à cette information, on peut déterminer que la première étape du voyage part à 15h55 de <i>Ecublens VD, EPFL</i> pour arriver à 16h01 à <i>Renens VD, gare</i>, simplement en consultant les liaisons qui suivent la première dans la course à laquelle elle appartient.\n</p>\n<p>\nUne fois la première étape déterminée, on peut consulter la frontière de Pareto de sa gare d'arrivée (<i>Renens VD, gare</i>) pour déterminer comment continuer le voyage. En effet, on sait que le tuple qui nous intéresse est celui permettant d'arriver à destination à 17h57 en effectuant encore 2 changements supplémentaires — étant donné que le premier des 3 changements totaux vient d'être fait.\n</p>\n<p>\nEn consultant la frontière de Pareto de <i>Renens VD, gare</i>, on y trouve le tuple \\((\\textrm{16h08}, \\textrm{17h57}, 2)\\) dont la charge utile contient :\n</p>\n<ul class=\"org-ul\">\n<li>l'identité de la liaison partant à 16h08 de <i>Renens VD</i> pour arriver à 16h14 à <i>Lausanne</i>,</li>\n<li>un nombre d'arrêts intermédiaires valant 0.</li>\n</ul>\n<p>\nOn peut en déterminer :\n</p>\n<ol class=\"org-ol\">\n<li>la prochaine étape du voyage, qui <i>doit</i> être une étape à pied allant de <i>Renens VD, gare</i> à <i>Renens VD</i>, car pour qu'un voyage soit valide il doit alterner les étapes en véhicule et à pied,</li>\n<li>la prochaine étape en véhicule du voyage, qui part de <i>Renens VD</i> à 16h08 et arrive à <i>Lausanne</i> à 16h14.</li>\n</ol>\n<p>\nPour continuer, il suffit de rechercher dans la frontière de Pareto associée à l'arrêt <i>Lausanne</i> le tuple permettant d'arriver à destination à 17h57 en effectuant encore 1 changement, puis de procéder comme ci-dessus. Et ainsi de suite jusqu'à ce qu'il ne reste plus de changements à effectuer.\n</p>\n</div>"
      },
      {
        "header": "2.5. Étapes initiales et finales",
        "content": "<div class=\"outline-text-3\" id=\"text-2-5\">\n<p>\nLa technique d'extraction de voyage présentée à la section précédente produit toujours des voyages dont la première et la dernière étape se font en véhicule et non à pied. Or parfois, l'une ou l'autre, ou les deux, de ces étapes doivent se faire à pied.\n</p>\n<p>\nPar exemple, si au lieu de partir depuis l'arrêt <i>Ecublens VD, EPFL</i>, on désire partir depuis l'arrêt <i>Ecublens VD, EPFL (bus)</i> — l'arrêt de bus se trouvant juste à côté de l'arrêt du m1 —, la première étape consiste à marcher jusqu'à l'arrêt du m1. Bien entendu, une situation similaire peut se produire pour la dernière étape d'un voyage.\n</p>\n<p>\nDès lors, la technique d'extraction mentionnée précédemment doit être légèrement augmentée afin d'ajouter une étape à pied initiale si la première liaison part d'un arrêt différent de l'arrêt de départ choisi. De même, une étape à pied finale doit être ajoutée si, après avoir effectué tous les changements requis, on se trouve à un arrêt qui n'est pas encore l'arrêt de destination.\n</p>\n</div>"
      }
    ]
  },
  "implementation": {
    "header": "3.1. Enregistrement FileTimeTable",
    "classes": [
      {
        "name": "FileTimeTable",
        "header": "3.1. Enregistrement FileTimeTable",
        "content": "<div class=\"outline-text-3\" id=\"text-3-1\">\n<p>\nL'enregistrement <code>FileTimeTable</code> du sous-paquetage <code>timetable.mapped</code>, public, implémente l'interface <code>TimeTable</code> et représente un horaire de transport public dont les données (aplaties) sont stockées dans des fichiers. Il possède les attributs suivants :\n</p>\n<dl class=\"org-dl\">\n<dt><code>Path directory</code></dt><dd>le chemin d'accès au dossier contenant les fichiers des données horaires,</dd>\n<dt><code>List&lt;String&gt; stringTable</code></dt><dd>la table des chaînes de caractères,</dd>\n<dt><code>Stations stations</code></dt><dd>les gares,</dd>\n<dt><code>StationAliases stationAliases</code></dt><dd>les noms alternatifs des gares,</dd>\n<dt><code>Platforms platforms</code></dt><dd>les voies/quai,</dd>\n<dt><code>Routes routes</code></dt><dd>les lignes,</dd>\n<dt><code>Transfers transfers</code></dt><dd>les changements.</dd>\n</dl>\n<p>\n<code>FileTimeTable</code> possède une méthode publique et statique facilitant la création d'une instance à partir du chemin d'accès au dossier contenant les données horaires :\n</p>\n<dl class=\"org-dl\">\n<dt><code>TimeTable in(Path directory) throws IOException</code></dt><dd>qui retourne une nouvelle instance de <code>FileTimeTable</code> dont les données aplaties ont été obtenues à partir des fichiers se trouvant dans le dossier dont le chemin d'accès est donné, en faisant l'hypothèse que ce dossier est organisé de la même manière que le dossier <code>timetable</code> de l'archive que nous vous fournissons ; lève une <code>IOException</code> en cas d'erreur d'entrée/sortie.</dd>\n</dl>\n<p>\nEn dehors de cette méthode statique, les seules méthodes publiques offertes par <code>FileTimeTable</code> sont des versions concrètes des méthodes abstraites de <code>TimeTable</code>.\n</p>\n</div>"
      },
      {
        "name": "Profile",
        "header": "3.2. Enregistrement Profile",
        "content": "<div class=\"outline-text-3\" id=\"text-3-2\">\n<p>\nL'enregistrement <code>Profile</code> du sous-paquetage <code>journey</code>, public et immuable, représente un profil. Il possède les attributs suivants :\n</p>\n<dl class=\"org-dl\">\n<dt><code>TimeTable timeTable</code></dt><dd>l'horaire auquel correspond le profil,</dd>\n<dt><code>LocalDate date</code></dt><dd>la date à laquelle correspond le profil,</dd>\n<dt><code>int arrStationId</code></dt><dd>l'index de la gare d'arrivée à laquelle correspond le profil,</dd>\n<dt><code>List&lt;ParetoFront&gt; stationFront</code></dt><dd>la table des frontières de Pareto de toutes les gares, qui contient, à un index donné, la frontière de la gare de même index.</dd>\n</dl>\n<p>\nLe constructeur compact de <code>Profile</code> copie la table des frontières de Pareto afin de garantir l'immuabilité de la classe.\n</p>\n<p>\n<code>Profile</code> possède les méthodes publiques suivantes :\n</p>\n<dl class=\"org-dl\">\n<dt><code>Connections connections()</code></dt><dd>qui retourne les liaisons correspondant au profil, qui sont simplement celles de l'horaire, à la date à laquelle correspond le profil,</dd>\n<dt><code>Trips trips()</code></dt><dd>qui retourne les courses correspondant au profil, qui sont simplement celles de l'horaire, à la date à laquelle correspond le profil,</dd>\n<dt><code>ParetoFront forStation(int stationId)</code></dt><dd>qui retourne la frontière de Pareto pour la gare d'index donné, ou lève une <code>IndexOutOfBoundsException</code> si cet index est invalide.</dd>\n</dl>\n</div>"
      },
      {
        "name": "Profile.Builder",
        "header": "3.3. Classe Profile.Builder",
        "content": "<div class=\"outline-text-3\" id=\"text-3-3\">\n<p>\nLa classe <code>Builder</code>, publique, finale et imbriquée statiquement dans l'enregistrement <code>Profile</code>, représente un bâtisseur de profil. Ce bâtisseur étant destiné à être utilisé lors du calcul des voyages optimaux, il stocke non seulement les frontières de Pareto en cours de construction pour les gares, mais aussi pour les courses. En d'autres termes, il représente un profil <i>augmenté</i> en cours de construction, mais finit par bâtir un profil simple.\n</p>\n<p>\n<code>Builder</code> offre un unique constructeur public :\n</p>\n<dl class=\"org-dl\">\n<dt><code>Builder(TimeTable timeTable, LocalDate date, int arrStationId)</code></dt><dd>qui construit un bâtisseur de profil pour l'horaire, la date et la gare de destination donnés.</dd>\n</dl>\n<p>\nLe constructeur stocke non seulement les arguments qu'on lui a passé dans des attributs, afin de pouvoir les passer plus tard au constructeur de <code>Profile</code>, mais il initialise également deux tableaux primitifs destinés à contenir les bâtisseurs des frontières de Pareto des gares et des courses. Ces tableaux ne doivent <i>pas</i> être remplis initialement, donc leurs éléments doivent tous être <code>null</code>.\n</p>\n<p>\nEn plus de ce constructeur, <code>Builder</code> offre les méthodes publiques suivantes :\n</p>\n<dl class=\"org-dl\">\n<dt><code>ParetoFront.Builder forStation(int stationId)</code></dt><dd>qui retourne le bâtisseur de la frontière de Pareto pour la gare d'index donné, qui est <code>null</code> si aucun appel à <code>setForStation</code> n'a été fait précédemment pour cette gare, ou lève une <code>IndexOutOfBoundsException</code> si l'index est invalide,</dd>\n<dt><code>void setForStation(int stationId, ParetoFront.Builder builder)</code></dt><dd>qui associe le bâtisseur de frontière de Pareto donné à la gare d'index donné, ou lève une <code>IndexOutOfBoundsException</code> si l'index est invalide,</dd>\n<dt><code>ParetoFront.Builder forTrip(int tripId)</code></dt><dd>qui fait la même chose que <code>forStation</code> mais pour la course d'index donné,</dd>\n<dt><code>void setForTrip(int tripId, ParetoFront.Builder builder)</code></dt><dd>qui fait la même chose que <code>setForStation</code> mais pour la course d'index donné,</dd>\n<dt><code>Profile build()</code></dt><dd>qui retourne le profil simple — sans les frontières de Pareto correspondant aux courses — en cours de construction.</dd>\n</dl>\n</div>"
      },
      {
        "name": "JourneyExtractor",
        "header": "3.4. Classe JourneyExtractor",
        "content": "<div class=\"outline-text-3\" id=\"text-3-4\">\n<p>\nLa classe <code>JourneyExtractor</code> du sous-paquetage <code>journey</code>, publique et non instanciable, représente un « extracteur de voyages » et contient une seule méthode publique :\n</p>\n<dl class=\"org-dl\">\n<dt><code>List&lt;Journey&gt; journeys(Profile profile, int depStationId)</code></dt><dd>qui retourne la totalité des voyages optimaux correspondant au profil et à la gare de départ donnés, triés d'abord par heure de départ (croissante) puis par heure d'arrivée (croissante).</dd>\n</dl>\n</div>"
      }
    ],
    "other_subsections": [
      {
        "header": "3.5. Tests",
        "content": "<div class=\"outline-text-3\" id=\"text-3-5\">\n<p>\nComme d'habitude, nous ne vous fournissons plus de tests mais <a href=\"f/SignatureChecks_6.java\">un fichier de vérification de signatures</a> à importer dans votre projet.\n</p>\n<p>\nPour vous aider à tester l'extraction de voyage, nous vous fournissons <a href=\"f/rechor_profile.zip\">une archive Zip</a> contenant un fichier nommé <code>profile_2025-03-18_11486.txt</code>. Il contient la représentation textuelle d'un profil pour le 18 mars 2025, avec la gare 11486 (<i>Gruyères</i>) comme destination. Chaque ligne correspond à une gare, dont les éléments de la frontière de Pareto sont représentés en base 16, séparés par des virgules. Par exemple, la première ligne du fichier commence ainsi :\n</p>\n<pre class=\"example\">\n552b298408159611,56db1b070a9ad404,570b0b840ad9ae11,…\n</pre>\n<p>\nce qui signifie que la frontière de Pareto associée à la gare d'index 0 dans le profil a comme premier tuple empaqueté 552b298408159611<sub>16</sub> — soit \\((\\textrm{18h50}, \\textrm{22h59}, 4)\\) avec une charge utile dont la liaison est celle d'index 529814 (81596<sub>16</sub>) et le nombre d'arrêts intermédiaires est 17 (11<sub>16</sub>).\n</p>\n<p>\nPour lire ce profil, vous pouvez vous inspirer du code ci-dessous, qui n'utilise que des concepts que vous connaissez déjà et que vous devriez donc pouvoir comprendre sans difficulté majeure :\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-java\">Profile readProfile(TimeTable timeTable,\n                    LocalDate date,\n                    int arrStationId) throws IOException {\n  Path path =\n    Path.of(\"profile_\" + date + \"_\" + arrStationId + \".txt\");\n  try (BufferedReader r = Files.newBufferedReader(path)) {\n    Profile.Builder profileB =\n      new Profile.Builder(timeTable, date, arrStationId);\n    int stationId = -1;\n    String line;\n    while ((line = r.readLine()) != null) {\n      stationId += 1;\n      if (line.isEmpty()) continue;\n      ParetoFront.Builder frontB = new ParetoFront.Builder();\n      for (String t : line.split(\",\"))\n        frontB.add(Long.parseLong(t, 16));\n      profileB.setForStation(stationId, frontB);\n    }\n    return profileB.build();\n  }\n}\n</pre>\n</div>\n<p>\nUne fois le profil lu, vous pouvez vérifier que votre code est correct en extrayant tous les voyages au départ de la gare 7872 (<i>Ecublens VD, EPFL</i>), et en convertissant celui d'index 32 en événement iCalendar, au moyen de code similaire à celui-ci :\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-java\">TimeTable t = FileTimeTable.in(Path.of(\"timetable\"));\nLocalDate date = LocalDate.of(2025, Month.MARCH, 18);\nProfile p = readProfile(t, date, 11486);\nList&lt;Journey&gt; js = JourneyExtractor.journeys(p, 7872);\nString j = JourneyIcalConverter.toIcalendar(js.get(32));\nSystem.out.println(j);\n</pre>\n</div>\n<p>\nVous devriez voir un événement iCalendar presque identique à celui de la <a href=\"02.html#sec/ical/example\">§2.1.8 de l'étape 2</a>.\n</p>\n</div>"
      }
    ]
  }
}