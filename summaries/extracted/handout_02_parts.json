{
  "intro": {
    "title": "iCalendar et valeurs empaquetées",
    "subtitle": "ReCHor – étape 2",
    "content": "<div class=\"outline-text-2\" id=\"text-1\">\n<p>\nLe but de cette seconde étape est double : premièrement, écrire le code permettant d'exporter un voyage au format iCalendar, et deuxièmement écrire celui permettant de manipuler deux types de valeurs « empaquetées » dans des entiers Java — les intervalles d'entiers, et les critères d'optimisation des voyages.\n</p>\n<p>\nAvant de la commencer, lisez le guide <a href=\"../g/backups.html\"><i>Sauvegarder son travail</i></a>, qui vous donnera des conseils importants concernant la sauvegarde de votre projet au cours du semestre.\n</p>\n</div>"
  },
  "concepts": {
    "header": "2.1. Format iCalendar",
    "subsections": [
      {
        "header": "2.1. Format iCalendar",
        "content": "<div class=\"outline-text-3\" id=\"text-2-1\">\n<p>\nComme nous l'avons vu dans <a href=\"00.html\">l'introduction au projet</a>, une des fonctionnalités offertes par ReCHor est l'exportation d'un voyage sous la forme d'un <b>événement</b> (<i>event</i>) destiné à être importé dans un calendrier électronique.\n</p>\n<p>\nCette fonctionnalité repose sur la norme <a href=\"https://icalendar.org/\">iCalendar</a> qui décrit la représentation, sous forme textuelle, d'événements dans un calendrier. Cette norme — adoptée par la plupart des calendriers électroniques — est très complète et complexe, mais dans le cadre de ce projet, nous n'en utiliserons qu'un petit sous-ensemble, décrit ci-après.\n</p>\n</div>"
      },
      {
        "header": "2.2. Valeurs empaquetées",
        "content": "<div class=\"outline-text-3\" id=\"text-2-2\">\n<p>\nComme expliqué dans le cours sur les types entiers, l'empaquetage consiste à stocker plusieurs valeurs dans les bits d'un « entier » Java, généralement pour économiser de la mémoire et améliorer les performances du programme.\n</p>\n<p>\nDans ce projet, nous représenterons plusieurs types de valeurs de manière empaquetée, dont les intervalles et les critères d'optimisations, décrits dans les sections qui suivent.\n</p>\n</div>"
      }
    ]
  },
  "implementation": {
    "header": "3.1. Classe IcalBuilder",
    "classes": [
      {
        "name": "IcalBuilder",
        "header": "3.1. Classe IcalBuilder",
        "content": "<div class=\"outline-text-3\" id=\"text-3-1\">\n<p>\nLa classe <code>IcalBuilder</code> du paquetage principal, publique et finale, représente un bâtisseur d'événement au format iCalendar. Elle possède deux types énumérés publics imbriqués, qui sont :\n</p>\n<dl class=\"org-dl\">\n<dt><code>Component</code></dt><dd>qui représente un composant ou un objet, et dont les valeurs sont (dans l'ordre) : <code>VCALENDAR</code> et <code>VEVENT</code>,</dd>\n<dt><code>Name</code></dt><dd>qui représente un nom d'une ligne, et dont les valeurs sont (dans l'ordre) : <code>BEGIN</code>, <code>END</code>, <code>PRODID</code>, <code>VERSION</code>, <code>UID</code>, <code>DTSTAMP</code>, <code>DTSTART</code>, <code>DTEND</code>, <code>SUMMARY</code> et <code>DESCRIPTION</code>.</dd>\n</dl>\n<p>\nDe plus, <code>IcalBuilder</code> possède les méthodes publiques suivantes :\n</p>\n<dl class=\"org-dl\">\n<dt><code>IcalBuilder add(Name name, String value)</code></dt><dd>qui ajoute à l'événement en cours de construction une ligne dont le nom et la valeur sont ceux donnés, en prenant garde à « plier » la ligne au besoin afin de respecter la contrainte qu'aucune ligne d'une donnée iCalendar ne devrait dépasser 75 caractères,</dd>\n<dt><code>IcalBuilder add(Name name, LocalDateTime dateTime)</code></dt><dd>qui ajoute à l'événement en cours de construction une ligne dont le nom est celui donné et la valeur est la représentation textuelle de la date/heure donnée, au format spécifié à la §<a href=\"#sec/ical/dt\">2.1.6</a>,</dd>\n<dt><code>IcalBuilder begin(Component component)</code></dt><dd>qui commence un composant en ajoutant une ligne dont le nom est <code>BEGIN</code> et la valeur est le nom du composant donné,</dd>\n<dt><code>IcalBuilder end()</code></dt><dd>qui termine le dernier composant qui a été commencé précédemment par <code>begin</code> mais pas encore terminé par un appel à <code>end</code> précédent, ou lève une <code>IllegalArgumentException</code> s'il n'y en a aucun (voir les conseils de programmation),</dd>\n<dt><code>String build()</code></dt><dd>qui retourne la chaîne de caractères au format iCalendar représentant l'événement en cours de construction, ou lève une <code>IllegalArgumentException</code> si un composant qui a été commencé par un appel à <code>begin</code> n'a, à ce stade, pas été terminé par un appel à <code>end</code>.</dd>\n</dl>\n</div>"
      },
      {
        "name": "JourneyIcalConverter",
        "header": "3.2. Classe JourneyIcalConverter",
        "content": "<div class=\"outline-text-3\" id=\"text-3-2\">\n<p>\nLa classe <code>JourneyIcalConverter</code> du sous-paquetage <code>journey</code>, publique et non instanciable, offre une méthode permettant de convertir un voyage en un événement :\n</p>\n<dl class=\"org-dl\">\n<dt><code>String toIcalendar(Journey journey)</code></dt><dd>qui retourne une chaîne de caractères au format iCalendar représentant l'événement qui correspond au voyage donné.</dd>\n</dl>\n<p>\nL'événement retourné par <code>toIcalendar</code> doit avoir exactement la même structure que celui donné en exemple à la §<a href=\"#sec/ical/example\">2.1.8</a>, et doit donc consister en :\n</p>\n<ul class=\"org-ul\">\n<li>un objet <code>VCALENDAR</code> à la racine avec :\n<ul class=\"org-ul\">\n<li>un attribut <code>VERSION</code> valant <code>2.0</code>,</li>\n<li>un attribut <code>PRODID</code> valant <code>ReCHor</code>,</li>\n<li>un composant <code>VEVENT</code> imbriqué avec :\n<ul class=\"org-ul\">\n<li>un attribut <code>UID</code> dont la valeur est un UUID aléatoire (voir les conseils de programmation),</li>\n<li>un attribut <code>DTSTAMP</code> dont la valeur est la date/heure au moment de l'appel de la méthode (voir les conseils de programmation),</li>\n<li>un attribut <code>DTSTART</code> dont la valeur est la date/heure du début du voyage,</li>\n<li>un attribut <code>DTEND</code> dont la valeur est la date/heure de la fin du voyage,</li>\n<li>un attribut <code>SUMMARY</code> dont la valeur est le nom de la gare de départ et celle d'arrivée, séparés d'une flèche (<code>→</code>) entourée d'espaces,</li>\n<li>un attribut <code>DESCRIPTION</code> dont la valeur est la représentation textuelle des différentes étapes du voyage, chacune sur une ligne, obtenue au moyen des méthodes de <code>FormatterFr</code>.</li>\n</ul></li>\n</ul></li>\n</ul>\n<p>\nPour vérifier que les événements produits par votre méthode sont syntaxiquement corrects, vous pouvez utiliser <a href=\"https://icalendar.org/validator.html\">le validateur iCalendar en ligne</a>.\n</p>\n</div>"
      },
      {
        "name": "Bits32_24_8",
        "header": "3.3. Classe Bits32_24_8",
        "content": "<div class=\"outline-text-3\" id=\"text-3-3\">\n<p>\nLa classe <code>Bits32_24_8</code> du paquetage principal, publique et non instanciable, contient des méthodes statiques permettant de manipuler une paire de valeurs — de 24 et 8 bits respectivement — empaquetées dans un entier de 32 bits de type <code>int</code>.\n</p>\n<p>\nCette classe existe car il se trouve que plusieurs paires de valeurs utiles dans ce projet, dont les intervalles d'entiers, peuvent être empaquetées de la sorte, et il semble donc raisonnable de partager le code les manipulant.\n</p>\n<p>\nLes méthodes publiques (et statiques) offertes par <code>Bits32_24_8</code> sont :\n</p>\n<dl class=\"org-dl\">\n<dt><code>int pack(int bits24, int bits8)</code></dt><dd>qui retourne le vecteur de 32 bits dont les 24 bits de poids fort sont <code>bits24</code> et les 8 bits de poids faible sont <code>bits8</code>, ou lève une <code>IllegalArgumentException</code> si l'une des deux valeurs nécessite plus de bits qu'elle ne devrait (24 et 8, respectivement, voir les conseils de programmation),</dd>\n<dt><code>int unpack24(int bits32)</code></dt><dd>qui retourne les 24 bits de poids fort du vecteur de 32 bits donné,</dd>\n<dt><code>int unpack8(int bits32)</code></dt><dd>qui retourne les 8 bits de poids faible du vecteur de 32 bits donné.</dd>\n</dl>\n</div>"
      },
      {
        "name": "PackedRange",
        "header": "3.4. Classe PackedRange",
        "content": "<div class=\"outline-text-3\" id=\"text-3-4\">\n<p>\nLa classe <code>PackedRange</code> du paquetage principal, publique et non instanciable, offre des méthodes permettant de manipuler des intervalles d'entiers empaquetés dans un entier de type <code>int</code>. Dans cette représentation, les 24 bits de poids fort contiennent la borne inférieure de l'intervalle, tandis que les 8 bits de poids faible contiennent sa longueur.\n</p>\n<p>\n<code>PackedRange</code> offre les méthodes publiques (et statiques) suivantes :\n</p>\n<dl class=\"org-dl\">\n<dt><code>int pack(int startInclusive, int endExclusive)</code></dt><dd>qui retourne la valeur de type <code>int</code> représentant l'intervalle d'entiers allant de <code>startInclusive</code> (inclus) à <code>endExclusive</code> (exclu), ou lève une <code>IllegalArgumentException</code> si cet intervalle ne peut pas être empaqueté (soit parce que sa borne inférieure ne peut être représentée avec 24 bits, ou parce que sa longueur ne peut être représentée avec 8 bits),</dd>\n<dt><code>int length(int interval)</code></dt><dd>qui retourne la longueur de l'intervalle d'entiers empaqueté donné,</dd>\n<dt><code>int startInclusive(int interval)</code></dt><dd>qui retourne le début de l'intervalle d'entiers empaqueté donné, c.-à-d. le plus petit entier qui en fait partie,</dd>\n<dt><code>int endExclusive(int interval)</code></dt><dd>qui retourne le plus petit entier strictement supérieur à tous les entiers de l'intervalle.</dd>\n</dl>\n</div>"
      },
      {
        "name": "PackedCriteria",
        "header": "3.5. Classe PackedCriteria",
        "content": "<div class=\"outline-text-3\" id=\"text-3-5\">\n<p>\nLa classe <code>PackedCriteria</code> du sous-paquetage <code>journey</code>, publique et non instanciable, contient des méthodes statiques permettant de manipuler des critères d'optimisation augmentés, empaquetés dans des valeurs de type <code>long</code>.\n</p>\n<p>\nPlusieurs de ses méthodes reçoivent en argument ou retournent en résultat une heure de départ ou d'arrivée. Attention, ces heures sont exprimées en minutes écoulées depuis minuit (!) et ne sont valides que si elles sont comprises entre -240 (inclus) et 2880 (exclu). Ce n'est qu'au moment d'être empaquetées que ces minutes sont « translatées » afin d'être exprimées en fonction de l'origine choisie plus haut (-240). Cette « translation » garantit que les minutes empaquetées sont toujours positives, ce qui simplifie le code.\n</p>\n<p>\n<code>PackedCriteria</code> offre les méthodes publiques (et statiques) suivantes :\n</p>\n<dl class=\"org-dl\">\n<dt><code>long pack(int arrMins, int changes, int payload)</code></dt><dd>qui retourne la valeur de type <code>long</code> résultant de l'empaquetage de l'heure d'arrivée, du nombre de changements et de la « charge utile » donnés, selon le format décrit à la §<a href=\"#sec/packed/criteria\">2.2.5</a> — c.-à-d. sans heure (minutes) de départ — ou lève une <code>IllegalArgumentException</code> si l'heure d'arrivée est invalide, ou si le nombre de changements ne tient pas dans 7 bits,</dd>\n<dt><code>boolean hasDepMins(long criteria)</code></dt><dd>qui retourne vrai ssi les critères empaquetés donnés incluent une heure de départ,</dd>\n<dt><code>int depMins(long criteria)</code></dt><dd>qui retourne l'heure de départ (en minutes après minuit) des critères empaquetés donnés, ou lève <code>IllegalArgumentException</code> si ces critères n'incluent pas une heure de départ,</dd>\n<dt><code>int arrMins(long criteria)</code></dt><dd>qui retourne l'heure d'arrivée (en minutes après minuit) des critères empaquetés donnés,</dd>\n<dt><code>int changes(long criteria)</code></dt><dd>qui retourne le nombre de changements des critères empaquetés donnés,</dd>\n<dt><code>int payload(long criteria)</code></dt><dd>qui retourne la « charge utile » associée aux critères empaquetés donnés,</dd>\n<dt><code>boolean dominatesOrIsEqual(long criteria1, long criteria2)</code></dt><dd>qui retourne vrai si et seulement si les premiers critères empaquetés dominent ou sont égaux aux seconds, ou lève une <code>IllegalArgumentException</code> l'un des ensembles de critères possède une heure de départ mais l'autre pas,</dd>\n<dt><code>long withoutDepMins(long criteria)</code></dt><dd>qui retourne des critères empaquetés identiques à ceux donnés, mais sans heure de départ,</dd>\n<dt><code>long withDepMins(long criteria, int depMins1)</code></dt><dd>qui retourne des critères empaquetés identiques à ceux donnés, mais avec l'heure de départ donnée,</dd>\n<dt><code>long withAdditionalChange(long criteria)</code></dt><dd>qui retourne des critères empaquetés identiques à ceux donnés, mais avec un changement de plus,</dd>\n<dt><code>long withPayload(long criteria, int payload1)</code></dt><dd>qui retourne des critères empaquetés identiques à ceux donnés, mais avec la « charge utile » donnée.</dd>\n</dl>\n</div>"
      }
    ],
    "other_subsections": [
      {
        "header": "3.6. Vérification des signatures",
        "content": "<div class=\"outline-text-3\" id=\"text-3-6\">\n<p>\nPour faciliter votre travail, nous mettons à votre disposition <a href=\"f/SignatureChecks_2.java\">un fichier de vérification de signatures</a>, nommé <code>SignatureChecks_2.java</code>, à importer dans votre projet dans le même dossier que celui contenant le fichier <code>SignatureChecks_1.java</code>. La classe qu'il contient fait référence à la totalité des classes et méthodes de cette étape, ce qui vous permet de vérifier que leurs noms et types sont corrects. Cela est capital, car la moindre faute à ce niveau empêcherait l'exécution de nos tests unitaires.\n</p>\n<p>\nNous vous fournirons de tels fichiers pour toutes les étapes jusqu'à la sixième (incluse), et il vous faudra penser à vérifier systématiquement qu'aucune erreur n'est signalée à leur sujet. Faute de cela, votre rendu pourrait se voir refusé par notre système.\n</p>\n</div>"
      },
      {
        "header": "3.7. Tests",
        "content": "<div class=\"outline-text-3\" id=\"text-3-7\">\n<p>\nÀ partir de cette étape, nous ne vous fournissons plus de tests unitaires, et il vous faut donc les écrire vous-même.\n</p>\n<p>\nNotez que, pour les étapes 2 à 6, nous mettrons à disposition nos tests le lundi suivant le jour de rendu de chaque étape. Vous aurez alors tout intérêt à les incorporer à votre projet, ce qui peut poser un problème de nommage.\n</p>\n<p>\nEn effet, si vous nommez vos tests selon la convention standard, en ajoutant simplement le suffixe <code>Test</code> au nom de la classe testée, vos tests auront le même nom que les nôtres, et il ne vous sera pas possible d'avoir vos tests et les nôtres dans un même projet. Pour cette raison, nous vous recommandons d'adopter une autre convention de nommage pour vos tests, par exemple en entourant le nom de la classe testée au moyen du préfixe <code>My</code> et du suffixe <code>Test</code>. Ainsi, votre test pour la classe <code>Rational</code> pourrait être nommé <code>MyRationalTest</code>.\n</p>\n</div>"
      }
    ]
  }
}